name: Rust Docs to Wiki

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*.rs'
      - 'Cargo.toml'
      - '.github/workflows/rust-docs-to-wiki.yml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  extract-docs-and-update-wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable

      - name: Install cargo-readme
        run: cargo install cargo-readme

      - name: Create wiki directories and base files
        run: |
          # Create directory for wiki content
          mkdir -p wiki-content
          
          # Create Home.md
          echo "# ${GITHUB_REPOSITORY#*/} Documentation" > wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "This wiki contains automatically generated documentation from the Rust codebase." >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "## Modules" >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          
          # Create template file for cargo-readme (avoid heredoc)
          echo "# {{title}}" > readme.tpl
          echo "" >> readme.tpl
          echo "Path: \`{{file_path}}\`" >> readme.tpl
          echo "" >> readme.tpl
          echo "{{readme}}" >> readme.tpl

      - name: Process Rust files
        run: |
          # Find all .rs files
          find src -name "*.rs" -type f > rs_files.txt
          
          # Process each file
          while IFS= read -r file; do
            # Get file info
            base_name=$(basename "$file" .rs)
            dir_path=$(dirname "$file")
            
            # Create unique filename
            unique_name=$(echo "${dir_path//\//_}_${base_name}" | sed 's/^src_//')
            output_file="wiki-content/${unique_name}.md"
            
            echo "Processing $file into $output_file"
            
            # Create temporary directory
            temp_dir=$(mktemp -d)
            mkdir -p "$temp_dir/src"
            
            # Copy file as lib.rs
            cp "$file" "$temp_dir/src/lib.rs"
            
            # Create minimal Cargo.toml (avoid heredoc)
            echo "[package]" > "$temp_dir/Cargo.toml"
            echo "name = \"$base_name\"" >> "$temp_dir/Cargo.toml"
            echo "version = \"0.1.0\"" >> "$temp_dir/Cargo.toml"
            echo "edition = \"2021\"" >> "$temp_dir/Cargo.toml"
            echo "" >> "$temp_dir/Cargo.toml"
            echo "[lib]" >> "$temp_dir/Cargo.toml"
            echo "path = \"src/lib.rs\"" >> "$temp_dir/Cargo.toml"
            
            # Generate documentation
            cd "$temp_dir"
            
            # Create JSON file with variables
            echo "{\"title\":\"$base_name ($dir_path)\",\"file_path\":\"$file\"}" > readme_extra.json
            
            # Run cargo-readme
            cargo readme --template "$GITHUB_WORKSPACE/readme.tpl" --output "$GITHUB_WORKSPACE/$output_file" --no-title --no-badge --no-license --json readme_extra.json
            
            # Return to workspace
            cd "$GITHUB_WORKSPACE"
            
            # Check if cargo-readme succeeded
            if [ ! -f "$output_file" ] || [ ! -s "$output_file" ]; then
              # Create minimal documentation file
              echo "# $base_name ($dir_path)" > "$output_file"
              echo "" >> "$output_file"
              echo "Path: \`$file\`" >> "$output_file"
              echo "" >> "$output_file"
              echo "## Public Items" >> "$output_file"
              echo "" >> "$output_file"
              
              # Extract public items
              grep -n "^pub " "$file" | while read -r line; do
                item=$(echo "$line" | cut -d: -f2-)
                # Clean up and format
                cleaned_item=$(echo "$item" | sed 's/{.*//' | sed 's/(.*//')
                echo "* \`$cleaned_item\`" >> "$output_file"
              done
            fi
            
            # Enhance with public API reference
            echo "" >> "$output_file"
            echo "## Public API Reference" >> "$output_file"
            echo "" >> "$output_file"
            
            # Create a separate AWK script file (avoids heredoc)
            cat > extract_pub_items.awk << 'AWKSCRIPT'
            BEGIN {
              in_pub_item = 0;
              pub_item = "";
              brace_count = 0;
            }
            
            /^pub / {
              if (!in_pub_item) {
                in_pub_item = 1;
                pub_item = $0;
                brace_count = 0;
                
                # Count opening braces
                for (i = 1; i <= length($0); i++) {
                  if (substr($0, i, 1) == "{") brace_count++;
                  if (substr($0, i, 1) == "}") brace_count--;
                }
                
                # If single line item
                if ($0 ~ /;$/ || brace_count == 0) {
                  print "### " $0;
                  print "";
                  print "```rust";
                  print pub_item;
                  print "```";
                  print "";
                  in_pub_item = 0;
                }
              }
              next;
            }
            
            # Multi-line pub item
            in_pub_item {
              pub_item = pub_item "\n" $0;
              
              # Count braces
              for (i = 1; i <= length($0); i++) {
                if (substr($0, i, 1) == "{") brace_count++;
                if (substr($0, i, 1) == "}") brace_count--;
              }
              
              # Check if definition is complete
              if (brace_count == 0 || $0 ~ /;$/ || $0 ~ /}$/) {
                print "### " substr(pub_item, 5, 50) (length(pub_item) > 55 ? "..." : "");
                print "";
                print "```rust";
                
                # Handle struct/enum with large bodies
                if (pub_item ~ /^pub (struct|enum|trait)/ && brace_count == 0) {
                  split_at = index(pub_item, "{");
                  if (split_at > 0) {
                    print substr(pub_item, 1, split_at) " ... }";
                  } else {
                    print pub_item;
                  }
                } else {
                  print pub_item;
                }
                
                print "```";
                print "";
                in_pub_item = 0;
              }
            }
            AWKSCRIPT
            
            # Run AWK script on the file
            awk -f extract_pub_items.awk "$file" >> "$output_file"
            
            # Add link to home page
            echo "* [$unique_name](${unique_name})" >> wiki-content/Home.md
            
            # Clean up
            rm -rf "$temp_dir"
          done < rs_files.txt

      - name: Setup Git for Wiki
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Clone Wiki Repository
        run: |
          # Use PAT for wiki push
          git clone https://${{ secrets.WIKI_TOKEN }}@github.com/${{ github.repository }}.wiki.git wiki-repo
          
          # Copy content to wiki
          cp -r wiki-content/* wiki-repo/
          
          cd wiki-repo
          git add .
          
          # Commit if changes exist
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update documentation from Rust code (${GITHUB_SHA:0:7})"
            git push
          fi

      - name: Upload Markdown as artifact
        uses: actions/upload-artifact@v4
        with:
          name: wiki-docs
          path: wiki-content/
