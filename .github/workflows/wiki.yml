name: Rust Docs to Wiki

# This workflow extracts documentation from Rust source code and updates the GitHub wiki.
# 
# IMPORTANT: This workflow requires a personal access token (PAT) with 'workflow' scope
# to push changes to the wiki repository. The default GITHUB_TOKEN doesn't have wiki permissions.
# 
# Setup instructions:
# 1. Create a personal access token with 'workflow' scope at:
#    https://github.com/settings/tokens
# 2. Add the token as a repository secret named 'WIKI_TOKEN' at:
#    https://github.com/YOUR_USERNAME/YOUR_REPO/settings/secrets/actions

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*.rs'
      - 'Cargo.toml'
      - '.github/workflows/rust-docs-to-wiki.yml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  extract-docs-and-update-wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable

      - name: Generate documentation in Markdown
        run: |
          # Create a directory for the wiki content
          mkdir -p wiki-content
          
          # Determine if this is a library or binary crate
          if grep -q "^\[lib\]" Cargo.toml; then
            echo "Library crate detected"
            IS_LIB=true
          else
            echo "Binary crate detected"
            IS_LIB=false
          fi
          
          # For each Rust file, extract doc comments directly
          find src -name "*.rs" | while read -r file; do
            # Get relative path for wiki structure
            rel_path=${file#src/}
            rel_path=${rel_path%.rs}
            dir_path="wiki-content/${rel_path%/*}"
            
            # Create directory if it doesn't exist
            mkdir -p "$dir_path"
            
            # Extract doc comments and convert to markdown
            file_name=$(basename "$file" .rs)
            output_file="wiki-content/${rel_path}.md"
            
            echo "# $file_name" > "$output_file"
            echo "" >> "$output_file"
            echo "Path: \`$file\`" >> "$output_file"
            echo "" >> "$output_file"
            
            # Generate table of contents header
            echo "## Table of Contents" >> "$output_file"
            echo "" >> "$output_file"
            
            # Collect all public items for table of contents
            toc_items=$(grep -n "^pub " "$file" | while read -r toc_line; do
              line_num=$(echo "$toc_line" | cut -d: -f1)
              item=$(echo "$toc_line" | cut -d: -f2-)
              
              # Get doc comments above this item
              prev_lines=$(head -n $((line_num-1)) "$file" | tac | sed -n '/\/\/\//p' | tac)
              
              if [ -n "$prev_lines" ]; then
                item_name=$(echo "$item" | sed 's/pub //' | sed 's/{.*//' | sed 's/(.*//' | tr -d '\n')
                echo "* [$item_name](#${item_name// /-})"
              fi
            done)
            
            echo "$toc_items" >> "$output_file"
            echo "" >> "$output_file"
            
            # Extract module-level documentation (//! comments)
            module_docs=$(grep -A 5 "//!" "$file" | sed 's/\/\/\!\s*//' | sed '/^--$/d')
            if [ -n "$module_docs" ]; then
              echo "## Module Documentation" >> "$output_file"
              echo "" >> "$output_file"
              echo "$module_docs" >> "$output_file"
              echo "" >> "$output_file"
            fi
            
            # Add section for public items
            echo "## Public Items" >> "$output_file"
            echo "" >> "$output_file"
            
            # Extract function/struct/trait names and doc comments
            grep -n "^pub " "$file" | while read -r line; do
              line_num=$(echo "$line" | cut -d: -f1)
              item=$(echo "$line" | cut -d: -f2-)
              
              # Get doc comments above this item (/// style comments)
              prev_lines=$(head -n $((line_num-1)) "$file" | tac | sed -n '/\/\/\//p' | tac)
              
              if [ -n "$prev_lines" ]; then
                # Extract the full function/type signature
                item_name=$(echo "$item" | sed 's/pub //' | sed 's/{.*//' | sed 's/(.*//' | tr -d '\n')
                
                # Find the end of the signature (either { or ; or where)
                start_line=$line_num
                end_line=$start_line
                
                # For function signatures that span multiple lines
                if ! echo "$item" | grep -q "{" && ! echo "$item" | grep -q ";" && ! echo "$item" | grep -q "where"; then
                  while [ $end_line -lt $(wc -l < "$file") ]; do
                    end_line=$((end_line + 1))
                    line_content=$(sed "${end_line}q;d" "$file")
                    
                    if echo "$line_content" | grep -q "{" || echo "$line_content" | grep -q ";" || echo "$line_content" | grep -q "where"; then
                      break
                    fi
                  done
                fi
                
                # Extract the full signature
                full_sig=$(sed -n "${start_line},${end_line}p" "$file")
                
                echo "### $item_name" >> "$output_file"
                echo "" >> "$output_file"
                echo '```rust' >> "$output_file"
                echo "$full_sig" >> "$output_file"
                echo '```' >> "$output_file"
                echo "" >> "$output_file"
                
                # Process doc comments with clear section formatting
                formatted_docs=$(echo "$prev_lines" | sed 's/\/\/\/\s*//' | 
                  # Convert "Arguments" or "Parameters" sections to h4
                  sed 's/^Arguments$/#### Arguments/' | 
                  sed 's/^Parameters$/#### Parameters/' |
                  # Convert "Returns" sections to h4
                  sed 's/^Returns$/#### Returns/' |
                  # Convert "Examples" sections to h4
                  sed 's/^Examples$/#### Examples/' |
                  # Convert "Note" or "Notes" sections to h4
                  sed 's/^Note$/#### Note/' |
                  sed 's/^Notes$/#### Notes/' |
                  # Convert "Error Handling" sections to h4
                  sed 's/^Error Handling$/#### Error Handling/' |
                  # Convert "Warning" sections to h4
                  sed 's/^Warning$/#### Warning/' |
                  # Convert "Use Cases" sections to h4
                  sed 's/^Use Cases$/#### Use Cases/' |
                  # Convert "Pagination" sections to h4
                  sed 's/^Pagination$/#### Pagination/' |
                  # Convert "Important" sections to h4
                  sed 's/^Important$/#### Important/')
                
                echo "$formatted_docs" >> "$output_file"
                echo "" >> "$output_file"
              fi
            done
          done
          
          # Create Home.md
          echo "# ${GITHUB_REPOSITORY#*/} Documentation" > wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "This wiki contains automatically generated documentation from the Rust codebase." >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "## Modules" >> wiki-content/Home.md
          
          # Add links to modules excluding Home.md
          find wiki-content -type f -name "*.md" ! -name "Home.md" | sort | while read -r file; do
            rel_file=${file#wiki-content/}
            module_name=$(basename "$file" .md)
            echo "* [$module_name]($rel_file)" >> wiki-content/Home.md
          done

      - name: Setup Git for Wiki
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Clone Wiki Repository
        run: |
          # Use PAT for wiki push (needs to be set in repository secrets)
          git clone https://${{ secrets.WIKI_TOKEN }}@github.com/${{ github.repository }}.wiki.git wiki-repo
          
          # Copy new content to wiki repository
          cp -r wiki-content/* wiki-repo/
          
          cd wiki-repo
          git add .
          
          # Only commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update documentation from Rust code (${GITHUB_SHA:0:7})"
            git push
          fi

      - name: Upload Markdown as artifact
        uses: actions/upload-artifact@v4
        with:
          name: wiki-docs
          path: wiki-content/
