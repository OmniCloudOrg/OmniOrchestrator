name: Rust Docs to Wiki

# This workflow extracts documentation from Rust source code and updates the GitHub wiki.
# 
# IMPORTANT: This workflow requires a personal access token (PAT) with 'workflow' scope
# to push changes to the wiki repository. The default GITHUB_TOKEN doesn't have wiki permissions.
# 
# Setup instructions:
# 1. Create a personal access token with 'workflow' scope at:
#    https://github.com/settings/tokens
# 2. Add the token as a repository secret named 'WIKI_TOKEN' at:
#    https://github.com/YOUR_USERNAME/YOUR_REPO/settings/secrets/actions

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*.rs'
      - 'Cargo.toml'
      - '.github/workflows/rust-docs-to-wiki.yml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  extract-docs-and-update-wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          components: rustfmt
          
      - name: Set Rust edition for toolchain
        run: |
          # Force Rust 2021 edition for toolchain and rustfmt
          echo 'edition = "2021"' > rustfmt.toml

      - name: Generate documentation
        run: |
          # Create directory for wiki content
          mkdir -p wiki-content
          
          # Create Home.md
          echo "# ${GITHUB_REPOSITORY#*/} Documentation" > wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "This wiki contains automatically generated documentation from the Rust codebase." >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "## Modules" >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          
          # Process each source file with guaranteed unique filenames
          find src -name "*.rs" -type f | while read -r file; do
            # Get file info
            base_name=$(basename "$file" .rs)
            dir_path=$(dirname "$file")
            
            # Convert path to a unique filename by replacing slashes with underscores
            unique_name=$(echo "${dir_path//\//_}_${base_name}" | sed 's/^src_//')
            output_file="wiki-content/${unique_name}.md"
            
            echo "Processing $file into $output_file"
            
            echo "# $base_name ($dir_path)" > "$output_file"
            echo "" >> "$output_file"
            echo "Path: \`$file\`" >> "$output_file"
            echo "" >> "$output_file"
            
            # Generate table of contents header
            echo "## Table of Contents" >> "$output_file"
            echo "" >> "$output_file"
            
            # First pass: Index all public items and their doc comments
            {
              # Use rustfmt with Rust 2021 edition (will handle async functions)
              # Fall back to cat if rustfmt still fails for any reason
              rustfmt "$file" --edition 2021 --emit=stdout 2>/dev/null || cat "$file" | 
              # Use AWK for more powerful parsing
              awk '
              BEGIN {
                in_doc_comment = 0;
                doc_comments = "";
                found_items = 0;
              }
              
              # Track doc comments (both inner and outer)
              /^\s*\/\/\/|^\s*\/\/\!/ {
                in_doc_comment = 1;
                doc_comments = doc_comments $0 "\n";
                next;
              }
              
              # Empty lines could be part of a doc comment block
              /^\s*$/ && in_doc_comment {
                doc_comments = doc_comments "\n";
                next;
              }
              
              # Match public items (functions, structs, traits, enums, etc.)
              /^\s*pub / {
                # Extract the item name and type
                match($0, /pub\s+(type|struct|enum|trait|fn|mod|use|const|union|impl)\s+([a-zA-Z0-9_]+)/, item_parts);
                
                if (item_parts[1] != "" && item_parts[2] != "") {
                  item_type = item_parts[1];
                  item_name = item_parts[2];
                  
                  # Only include if we have doc comments
                  if (doc_comments != "") {
                    # Remove any code indentation from the name for anchor links
                    clean_name = item_name;
                    gsub(/\s/, "-", clean_name);
                    
                    print "* [" item_type " " item_name "](#" tolower(clean_name) ")";
                    found_items = 1;
                  }
                }
                
                # Reset for next item
                in_doc_comment = 0;
                doc_comments = "";
                next;
              }
              
              # Any other line resets doc comment tracking
              {
                in_doc_comment = 0;
                doc_comments = "";
              }
              
              END {
                if (!found_items) {
                  print "No documented public items found.";
                }
              }
              '
            } >> "$output_file"
            
            echo "" >> "$output_file"
            
            # Extract module-level documentation (//! comments)
            {
              rustfmt "$file" --edition 2021 --emit=stdout 2>/dev/null || cat "$file" |
              awk '
              BEGIN {
                in_module_doc = 0;
                module_docs = "";
              }
              
              /^\s*\/\/\!/ {
                in_module_doc = 1;
                # Remove //! prefix and trim whitespace
                gsub(/^\s*\/\/\!\s*/, "");
                module_docs = module_docs $0 "\n";
                next;
              }
              
              # Empty lines could be part of module docs
              /^\s*$/ && in_module_doc {
                module_docs = module_docs "\n";
                next;
              }
              
              # Any non-empty, non-module-doc line ends module docs
              !/^\s*\/\/\!/ && !/^\s*$/ && in_module_doc {
                in_module_doc = 0;
                next;
              }
              
              END {
                if (module_docs != "") {
                  print "## Module Documentation";
                  print "";
                  print module_docs;
                  print "";
                } else {
                  print ""; # Just a blank line if no module docs
                }
              }
              '
            } >> "$output_file"
            
            # Add section for public items with their documentation
            echo "## Public Items" >> "$output_file"
            echo "" >> "$output_file"
            
            # Second pass: Extract full documentation for each item
            {
              rustfmt "$file" --edition 2021 --emit=stdout 2>/dev/null || cat "$file" |
              awk '
              BEGIN {
                in_doc_comment = 0;
                doc_comments = "";
                in_item_def = 0;
                item_def = "";
                item_name = "";
                item_type = "";
                brace_count = 0;
              }
              
              # Track doc comments
              /^\s*\/\/\// {
                in_doc_comment = 1;
                # Remove /// prefix and trim whitespace
                clean_line = $0;
                gsub(/^\s*\/\/\/\s?/, "", clean_line);
                doc_comments = doc_comments clean_line "\n";
                next;
              }
              
              # Empty lines could be part of a doc comment block
              /^\s*$/ && in_doc_comment {
                doc_comments = doc_comments "\n";
                next;
              }
              
              # Handle public items
              /^\s*pub / && !in_item_def {
                # If we have doc comments, this is a documented item
                if (doc_comments != "") {
                  in_item_def = 1;
                  item_def = $0;
                  
                  # Extract item type and name
                  match($0, /pub\s+(type|struct|enum|trait|fn|mod|use|const|union|impl)\s+([a-zA-Z0-9_]+)/, item_parts);
                  
                  if (item_parts[1] != "" && item_parts[2] != "") {
                    item_type = item_parts[1];
                    item_name = item_parts[2];
                  } else {
                    # Fallback for items that dont match the pattern
                    item_type = "item";
                    match($0, /pub\s+([a-zA-Z0-9_]+)/, alt_name);
                    item_name = alt_name[1] ? alt_name[1] : "unknown";
                  }
                  
                  # Count opening braces if any
                  brace_count = 0;
                  count = gsub(/\{/, "{", $0);
                  brace_count += count;
                  
                  # Check if definition ends on this line (with semicolon or where clause)
                  if ($0 ~ /;$/ || $0 ~ /\bwhere\b.*$/) {
                    # Print the item with its documentation
                    print "### " item_type " " item_name;
                    print "";
                    print "```rust";
                    print item_def;
                    print "```";
                    print "";
                    print doc_comments;
                    print "";
                    
                    # Reset for next item
                    in_item_def = 0;
                    doc_comments = "";
                    item_def = "";
                  }
                } else {
                  # No doc comments, skip this item
                  next;
                }
              }
              
              # Continue collecting multi-line item definitions
              in_item_def {
                item_def = item_def "\n" $0;
                
                # Count braces to track nested blocks
                count_open = gsub(/\{/, "{", $0);
                count_close = gsub(/\}/, "}", $0);
                brace_count += count_open - count_close;
                
                # Check if definition ends on this line
                if (brace_count == 0 && ($0 ~ /;$/ || $0 ~ /\}$/)) {
                  # Extract signature for functions (up to opening brace)
                  if (item_type == "fn") {
                    # Capture everything until the first {
                    full_def = item_def;
                    gsub(/\{.*$/, "{...}", item_def);
                  }
                  
                  # Print the item with its documentation
                  print "### " item_type " " item_name;
                  print "";
                  print "```rust";
                  print item_def;
                  print "```";
                  print "";
                  
                  # Process doc comments to handle markdown formatting
                  processed_comments = doc_comments;
                  gsub(/^# /, "### ", processed_comments);
                  gsub(/^#\s*Arguments$/, "### Arguments", processed_comments);
                  gsub(/^#\s*Parameters$/, "### Parameters", processed_comments);
                  gsub(/^#\s*Returns$/, "### Returns", processed_comments);
                  gsub(/^#\s*Examples$/, "### Examples", processed_comments);
                  gsub(/^#\s*Note$/, "### Note", processed_comments);
                  
                  print processed_comments;
                  print "";
                  
                  # Reset for next item
                  in_item_def = 0;
                  doc_comments = "";
                  item_def = "";
                  brace_count = 0;
                }
              }
              
              # Any other line resets doc comment tracking without resetting item tracking
              !in_item_def && !/^\s*$/ {
                in_doc_comment = 0;
                doc_comments = "";
              }
              '
            } >> "$output_file"
            
            # Add a link to the home page
            echo "* [$unique_name]($unique_name)" >> wiki-content/Home.md
          done

      - name: Setup Git for Wiki
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Clone Wiki Repository
        run: |
          # Use PAT for wiki push (needs to be set in repository secrets)
          git clone https://${{ secrets.WIKI_TOKEN }}@github.com/${{ github.repository }}.wiki.git wiki-repo
          
          # Copy new content to wiki repository
          cp -r wiki-content/* wiki-repo/
          
          cd wiki-repo
          git add .
          
          # Only commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update documentation from Rust code (${GITHUB_SHA:0:7})"
            git push
          fi

      - name: Upload Markdown as artifact
        uses: actions/upload-artifact@v4
        with:
          name: wiki-docs
          path: wiki-content/
