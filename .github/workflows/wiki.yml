name: Rust Docs to Wiki

# This workflow extracts documentation from Rust source code and updates the GitHub wiki.
# 
# IMPORTANT: This workflow requires a personal access token (PAT) with 'workflow' scope
# to push changes to the wiki repository. The default GITHUB_TOKEN doesn't have wiki permissions.
# 
# Setup instructions:
# 1. Create a personal access token with 'workflow' scope at:
#    https://github.com/settings/tokens
# 2. Add the token as a repository secret named 'WIKI_TOKEN' at:
#    https://github.com/YOUR_USERNAME/YOUR_REPO/settings/secrets/actions

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*.rs'
      - 'Cargo.toml'
      - '.github/workflows/rust-docs-to-wiki.yml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  extract-docs-and-update-wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable

      - name: Prepare file mapping
        run: |
          # Create directories for temp storage and wiki content
          mkdir -p file-mapping
          mkdir -p wiki-content
          
          # First, scan all source files and check for potential filename conflicts
          echo "Scanning source files for potential filename conflicts..."
          
          # Generate a list of all .rs files with their potential wiki page names
          find src -name "*.rs" | while read -r file; do
            base_name=$(basename "$file" .rs)
            echo "$file:$base_name" >> file-mapping/potential-names.txt
          done
          
          # Find duplicate base names
          cat file-mapping/potential-names.txt | cut -d: -f2 | sort | uniq -d > file-mapping/duplicates.txt
          
          # Create a mapping file showing the complete filepath to wiki name mapping
          > file-mapping/final-mapping.txt
          
          # For each source file, determine the wiki page name
          cat file-mapping/potential-names.txt | while read -r line; do
            source_file=$(echo "$line" | cut -d: -f1)
            base_name=$(echo "$line" | cut -d: -f2)
            
            # Check if this base name is in the duplicates list
            if grep -q "^$base_name$" file-mapping/duplicates.txt; then
              # It's a duplicate, need to include parent directories
              dir_path=$(dirname "$source_file")
              
              # Start with just the immediate parent
              wiki_name="${dir_path##*/}_${base_name}"
              
              # Keep adding parent directories until unique
              while grep -q ":$wiki_name$" file-mapping/final-mapping.txt; do
                dir_path=$(dirname "$dir_path")
                parent=$(basename "$dir_path")
                wiki_name="${parent}_${wiki_name}"
              done
              
              echo "$source_file:$wiki_name" >> file-mapping/final-mapping.txt
              echo "Mapped duplicate: $source_file → $wiki_name"
            else
              # Not a duplicate, use base name
              echo "$source_file:$base_name" >> file-mapping/final-mapping.txt
            fi
          done
          
          # Determine if this is a library or binary crate
          if grep -q "^\[lib\]" Cargo.toml; then
            echo "Library crate detected"
            IS_LIB=true
          else
            echo "Binary crate detected"
            IS_LIB=false
          fi

      - name: Generate documentation
        run: |
          # For each Rust file, extract doc comments
          cat file-mapping/final-mapping.txt | while read -r mapping; do
            source_file=$(echo "$mapping" | cut -d: -f1)
            wiki_name=$(echo "$mapping" | cut -d: -f2)
            
            echo "Processing $source_file → $wiki_name"
            
            # Create output file
            output_file="wiki-content/${wiki_name}.md"
            
            # Extract doc comments and convert to markdown
            echo "# $wiki_name" > "$output_file"
            echo "" >> "$output_file"
            echo "Path: \`$source_file\`" >> "$output_file"
            echo "" >> "$output_file"
            
            # Generate table of contents header
            echo "## Table of Contents" >> "$output_file"
            echo "" >> "$output_file"
            
            # Collect all public items for table of contents
            toc_items=$(grep -n "^pub " "$source_file" | while read -r toc_line; do
              line_num=$(echo "$toc_line" | cut -d: -f1)
              item=$(echo "$toc_line" | cut -d: -f2-)
              
              # Get doc comments above this item
              prev_lines=$(head -n $((line_num-1)) "$source_file" | tac | sed -n '/\/\/\//p' | tac)
              
              if [ -n "$prev_lines" ]; then
                item_name=$(echo "$item" | sed 's/pub //' | sed 's/{.*//' | sed 's/(.*//' | tr -d '\n')
                echo "* [$item_name](#${item_name// /-})"
              fi
            done)
            
            echo "$toc_items" >> "$output_file"
            echo "" >> "$output_file"
            
            # Extract module-level documentation (//! comments)
            module_docs=$(grep -A 5 "//!" "$source_file" | sed 's/\/\/\!\s*//' | sed '/^--$/d')
            if [ -n "$module_docs" ]; then
              echo "## Module Documentation" >> "$output_file"
              echo "" >> "$output_file"
              echo "$module_docs" >> "$output_file"
              echo "" >> "$output_file"
            fi
            
            # Add section for public items
            echo "# Public Items" >> "$output_file"
            echo "" >> "$output_file"
            
            # Extract function/struct/trait names and doc comments
            grep -n "^pub " "$source_file" | while read -r line; do
              line_num=$(echo "$line" | cut -d: -f1)
              item=$(echo "$line" | cut -d: -f2-)
              
              # Get doc comments above this item (/// style comments)
              prev_lines=$(head -n $((line_num-1)) "$source_file" | tac | sed -n '/\/\/\//p' | tac)
              
              if [ -n "$prev_lines" ]; then
                # Extract the full function/type signature
                item_name=$(echo "$item" | sed 's/pub //' | sed 's/{.*//' | sed 's/(.*//' | tr -d '\n')
                
                # Find the end of the signature (either { or ; or where)
                start_line=$line_num
                end_line=$start_line
                
                # For function signatures that span multiple lines
                if ! echo "$item" | grep -q "{" && ! echo "$item" | grep -q ";" && ! echo "$item" | grep -q "where"; then
                  while [ $end_line -lt $(wc -l < "$source_file") ]; do
                    end_line=$((end_line + 1))
                    line_content=$(sed "${end_line}q;d" "$source_file")
                    
                    if echo "$line_content" | grep -q "{" || echo "$line_content" | grep -q ";" || echo "$line_content" | grep -q "where"; then
                      break
                    fi
                  done
                fi
                
                # Extract the full signature
                full_sig=$(sed -n "${start_line},${end_line}p" "$source_file")
                
                echo "## $item_name" >> "$output_file"
                echo "" >> "$output_file"
                echo '```rust' >> "$output_file"
                echo "$full_sig" >> "$output_file"
                echo '```' >> "$output_file"
                echo "" >> "$output_file"
                
                # Process doc comments with clear section formatting
                formatted_docs=$(echo "$prev_lines" | sed 's/\/\/\/\s*//' | 
                  # Convert "Arguments" or "Parameters" sections to h3
                  sed 's/^Arguments$/### Arguments/' | 
                  sed 's/^Parameters$/### Parameters/' |
                  # Convert "Returns" sections to h3
                  sed 's/^Returns$/### Returns/' |
                  # Convert "Examples" sections to h3
                  sed 's/^Examples$/### Examples/' |
                  # Convert "Note" or "Notes" sections to h3
                  sed 's/^Note$/### Note/' |
                  sed 's/^Notes$/### Notes/' |
                  # Convert "Error Handling" sections to h3
                  sed 's/^Error Handling$/### Error Handling/' |
                  # Convert "Warning" sections to h3
                  sed 's/^Warning$/### Warning/' |
                  # Convert "Use Cases" sections to h3
                  sed 's/^Use Cases$/### Use Cases/' |
                  # Convert "Pagination" sections to h3
                  sed 's/^Pagination$/### Pagination/' |
                  # Convert "Important" sections to h3
                  sed 's/^Important$/### Important/')
                
                echo "$formatted_docs" >> "$output_file"
                echo "" >> "$output_file"
              fi
            done
          done
          
          # Create Home.md
          echo "# ${GITHUB_REPOSITORY#*/} Documentation" > wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "This wiki contains automatically generated documentation from the Rust codebase." >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "## Modules" >> wiki-content/Home.md
          
          # Add links to modules excluding Home.md
          find wiki-content -type f -name "*.md" ! -name "Home.md" | sort | while read -r file; do
            rel_file=${file#wiki-content/}
            module_name=$(basename "$file" .md)
            echo "* [$module_name]($rel_file)" >> wiki-content/Home.md
          done

      - name: Setup Git for Wiki
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Clone Wiki Repository
        run: |
          # Use PAT for wiki push (needs to be set in repository secrets)
          git clone https://${{ secrets.WIKI_TOKEN }}@github.com/${{ github.repository }}.wiki.git wiki-repo
          
          # Copy new content to wiki repository
          cp -r wiki-content/* wiki-repo/
          
          cd wiki-repo
          git add .
          
          # Only commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update documentation from Rust code (${GITHUB_SHA:0:7})"
            git push
          fi

      - name: Upload Markdown as artifact
        uses: actions/upload-artifact@v4
        with:
          name: wiki-docs
          path: wiki-content/
