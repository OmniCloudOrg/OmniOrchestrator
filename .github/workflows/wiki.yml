name: Rust Docs to Wiki Generator

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*.rs'
      - 'Cargo.toml'
      - '.github/workflows/rust-docs-to-wiki.yml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  generate-wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable

      - name: Create wiki directories
        run: |
          # Create directory for wiki content
          mkdir -p wiki-content
          
          # Create Home.md
          echo "# ${GITHUB_REPOSITORY#*/} Documentation" > wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "This wiki contains automatically generated documentation from the Rust codebase." >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "## Modules" >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md

      - name: Create rustdoc extractor
        run: |
          # This script processes Rust files and extracts documentation
          cat > extract_docs.py << 'EOF'
          #!/usr/bin/env python3
          import os
          import re
          import sys
          import subprocess
          from pathlib import Path
          
          def main():
              if len(sys.argv) < 3:
                  print("Usage: python extract_docs.py <source_dir> <output_dir>")
                  return 1
                  
              source_dir = Path(sys.argv[1])
              output_dir = Path(sys.argv[2])
              
              if not source_dir.is_dir():
                  print(f"Error: Source directory does not exist: {source_dir}")
                  return 1
                  
              if not output_dir.is_dir():
                  print(f"Error: Output directory does not exist: {output_dir}")
                  return 1
              
              # Process all Rust files
              rust_files = list(source_dir.glob("**/*.rs"))
              for file_path in sorted(rust_files):
                  try:
                      process_file(file_path, source_dir, output_dir)
                  except Exception as e:
                      print(f"Error processing {file_path}: {e}")
                      # Continue with next file
              
              return 0
          
          def process_file(file_path, source_dir, output_dir):
              """Process a single Rust file and extract documentation"""
              # Create unique filename for wiki page
              rel_path = file_path.relative_to(source_dir)
              unique_name = str(rel_path).replace('/', '_').replace('.rs', '')
              output_file = output_dir / f"{unique_name}.md"
              
              print(f"Processing {file_path} -> {output_file}")
              
              # Get file info
              base_name = file_path.stem
              dir_path = str(file_path.parent)
              
              with open(output_file, "w") as f:
                  # Create header
                  f.write(f"# {base_name} ({dir_path})\n\n")
                  f.write(f"Path: `{file_path}`\n\n")
                  
                  # Extract module docs
                  module_docs = extract_module_docs(file_path)
                  if module_docs:
                      f.write("## Module Documentation\n\n")
                      f.write(module_docs)
                      f.write("\n\n")
                  
                  # Extract public items
                  items = extract_all_public_items(file_path)
                  if items:
                      f.write("## Table of Contents\n\n")
                      for item in items:
                          item_type, item_name = item["type"], item["name"]
                          anchor = item_name.lower()
                          f.write(f"* [{item_type} {item_name}](#{anchor})\n")
                      f.write("\n")
                      
                      f.write("## Public Items\n\n")
                      for item in items:
                          item_type = item["type"]
                          item_name = item["name"]
                          doc_comment = item["doc"]
                          signature = item["signature"]
                          fields = item.get("fields", [])
                          
                          f.write(f"### {item_type} {item_name}\n\n")
                          
                          if doc_comment:
                              f.write(format_doc_comment(doc_comment))
                              f.write("\n\n")
                          
                          f.write("```rust\n")
                          f.write(signature)
                          f.write("\n```\n\n")
                          
                          # Add documentation for struct fields or enum variants
                          if fields:
                              f.write("#### Fields/Variants\n\n")
                              for field in fields:
                                  field_name = field["name"]
                                  field_doc = field["doc"]
                                  field_type = field.get("type", "")
                                  
                                  if field_name:
                                      if field_type:
                                          f.write(f"* `{field_name}: {field_type}`")
                                      else:
                                          f.write(f"* `{field_name}`")
                                      
                                      if field_doc:
                                          f.write(f" - {field_doc}")
                                      
                                      f.write("\n")
                              f.write("\n")
              
              # Add link to Home.md
              with open(output_dir / "Home.md", "a") as f:
                  f.write(f"* [{unique_name}]({unique_name})\n")
          
          def extract_module_docs(file_path):
              """Extract module-level documentation (//! comments)"""
              module_docs = []
              with open(file_path, "r") as f:
                  for line in f:
                      if re.match(r'^\s*//!', line):
                          comment = re.sub(r'^\s*//!\s?', '', line).rstrip()
                          module_docs.append(comment)
              
              return format_doc_comment("\n".join(module_docs)) if module_docs else ""
          
          def extract_doc_comment(lines, start_idx):
              """Extract a block of doc comments starting at a specific line"""
              doc_lines = []
              i = start_idx
              
              while i < len(lines) and re.match(r'^\s*///', lines[i]):
                  comment = re.sub(r'^\s*///\s?', '', lines[i]).rstrip()
                  doc_lines.append(comment)
                  i += 1
              
              # Skip empty lines after doc comment
              while i < len(lines) and not lines[i].strip():
                  i += 1
              
              return "\n".join(doc_lines), i
          
          def extract_struct_fields(lines, start_idx):
              """Extract field documentation from a struct definition"""
              fields = []
              i = start_idx
              brace_level = 0
              in_struct_body = False
              current_doc = ""
              
              # Find opening brace
              while i < len(lines) and "{" not in lines[i]:
                  i += 1
              
              if i < len(lines) and "{" in lines[i]:
                  in_struct_body = True
                  brace_level = 1
                  i += 1
              else:
                  return fields, i
              
              # Process the struct body
              while i < len(lines) and in_struct_body:
                  line = lines[i].strip()
                  
                  # Track brace level
                  brace_level += line.count("{") - line.count("}")
                  if brace_level == 0:
                      in_struct_body = False
                      break
                  
                  # Check for doc comment
                  if line.startswith("///"):
                      doc_comment, i = extract_doc_comment(lines, i)
                      current_doc = doc_comment
                      continue
                  
                  # Check for field
                  if not line.startswith("//") and not line.startswith("#") and line and ":" in line:
                      # Extract field name and type
                      field_match = re.match(r'(?:pub\s+)?([a-zA-Z0-9_]+)\s*:\s*(.+?)(?:,|$)', line)
                      if field_match:
                          field_name = field_match.group(1)
                          field_type = field_match.group(2).strip()
                          
                          fields.append({
                              "name": field_name,
                              "type": field_type,
                              "doc": current_doc
                          })
                          current_doc = ""
                  
                  i += 1
              
              return fields, i
          
          def extract_enum_variants(lines, start_idx):
              """Extract variant documentation from an enum definition"""
              variants = []
              i = start_idx
              brace_level = 0
              in_enum_body = False
              current_doc = ""
              
              # Find opening brace
              while i < len(lines) and "{" not in lines[i]:
                  i += 1
              
              if i < len(lines) and "{" in lines[i]:
                  in_enum_body = True
                  brace_level = 1
                  i += 1
              else:
                  return variants, i
              
              # Process the enum body
              while i < len(lines) and in_enum_body:
                  line = lines[i].strip()
                  
                  # Track brace level
                  brace_level += line.count("{") - line.count("}")
                  if brace_level == 0:
                      in_enum_body = False
                      break
                  
                  # Check for doc comment
                  if line.startswith("///"):
                      doc_comment, i = extract_doc_comment(lines, i)
                      current_doc = doc_comment
                      continue
                  
                  # Check for variant
                  if not line.startswith("//") and not line.startswith("#") and line:
                      # Extract variant name
                      variant_match = re.match(r'([A-Z][a-zA-Z0-9_]*)(?:\s*\(.*\)|\s*{.*})?(?:,|$)', line)
                      if variant_match:
                          variant_name = variant_match.group(1)
                          
                          variants.append({
                              "name": variant_name,
                              "doc": current_doc
                          })
                          current_doc = ""
                  
                  i += 1
              
              return variants, i
          
          def extract_item_signature(lines, start_idx, max_lines=20):
              """Extract a reasonable signature for an item"""
              signature_lines = [lines[start_idx]]
              i = start_idx + 1
              
              # If the item is one line (ends with semicolon)
              if ";" in lines[start_idx] and "{" not in lines[start_idx]:
                  return lines[start_idx], i
              
              # Track braces for multi-line items
              brace_count = lines[start_idx].count("{") - lines[start_idx].count("}")
              
              # If opening brace is on the first line
              if "{" in lines[start_idx]:
                  # For structs and enums, show a reasonable number of fields
                  if "struct " in lines[start_idx] or "enum " in lines[start_idx]:
                      line_count = 0
                      while i < len(lines) and brace_count > 0 and line_count < max_lines:
                          line = lines[i]
                          signature_lines.append(line)
                          brace_count += line.count("{") - line.count("}")
                          line_count += 1
                          i += 1
                          
                          if brace_count == 0:
                              break
                      
                      # If we didn't capture the closing brace, add ellipsis
                      if brace_count > 0:
                          signature_lines.append("    // ... additional fields/variants")
                          signature_lines.append("}")
                  else:
                      # For functions, just show the first line with brace
                      signature_lines.append("    // ... implementation")
                      signature_lines.append("}")
                      i += 1
              else:
                  # For multi-line signatures without braces yet
                  line_count = 0
                  
                  # Continue until we find a line with brace or semicolon
                  while i < len(lines) and "{" not in lines[i] and ";" not in lines[i] and line_count < max_lines:
                      signature_lines.append(lines[i])
                      line_count += 1
                      i += 1
                      
                      # If end of file or max lines reached
                      if i >= len(lines) or line_count >= max_lines:
                          break
                  
                  # If we find an opening brace, add it plus ellipsis
                  if i < len(lines) and "{" in lines[i]:
                      signature_lines.append(lines[i])
                      signature_lines.append("    // ... implementation")
                      signature_lines.append("}")
                      i += 1
                  elif i < len(lines) and ";" in lines[i]:
                      signature_lines.append(lines[i])
                      i += 1
              
              return "\n".join(signature_lines), i
          
          def extract_all_public_items(file_path):
              """Extract all public items with their documentation"""
              with open(file_path, "r") as f:
                  content = f.read()
              
              lines = content.split('\n')
              items = []
              i = 0
              
              while i < len(lines):
                  line = lines[i].strip()
                  
                  # Skip empty lines
                  if not line:
                      i += 1
                      continue
                  
                  # Check for doc comments
                  if line.startswith("///"):
                      doc_comment, next_i = extract_doc_comment(lines, i)
                      
                      # Check if followed by a public item
                      if next_i < len(lines) and lines[next_i].strip().startswith("pub "):
                          pub_line = lines[next_i].strip()
                          
                          # Determine item type and name
                          item_type, item_name = "item", ""
                          fields = []
                          
                          # Handle different item types
                          if "pub struct " in pub_line:
                              item_type = "struct"
                              match = re.search(r'struct\s+([a-zA-Z0-9_]+)', pub_line)
                              if match:
                                  item_name = match.group(1)
                                  
                                  # Extract signature with a reasonable amount of fields
                                  signature, field_end = extract_item_signature(lines, next_i)
                                  
                                  # Extract field documentation
                                  fields, _ = extract_struct_fields(lines, next_i)
                                  
                                  items.append({
                                      "type": item_type,
                                      "name": item_name,
                                      "doc": doc_comment,
                                      "signature": signature,
                                      "fields": fields
                                  })
                                  
                                  i = field_end
                                  continue
                          
                          elif "pub enum " in pub_line:
                              item_type = "enum"
                              match = re.search(r'enum\s+([a-zA-Z0-9_]+)', pub_line)
                              if match:
                                  item_name = match.group(1)
                                  
                                  # Extract signature with a reasonable amount of variants
                                  signature, variant_end = extract_item_signature(lines, next_i)
                                  
                                  # Extract variant documentation
                                  fields, _ = extract_enum_variants(lines, next_i)
                                  
                                  items.append({
                                      "type": item_type,
                                      "name": item_name,
                                      "doc": doc_comment,
                                      "signature": signature,
                                      "fields": fields
                                  })
                                  
                                  i = variant_end
                                  continue
                          
                          elif "pub trait " in pub_line:
                              item_type = "trait"
                              match = re.search(r'trait\s+([a-zA-Z0-9_]+)', pub_line)
                              if match:
                                  item_name = match.group(1)
                          
                          elif "pub async fn " in pub_line:
                              item_type = "async fn"
                              match = re.search(r'async\s+fn\s+([a-zA-Z0-9_]+)', pub_line)
                              if match:
                                  item_name = match.group(1)
                          
                          elif "pub fn " in pub_line:
                              item_type = "fn"
                              match = re.search(r'fn\s+([a-zA-Z0-9_]+)', pub_line)
                              if match:
                                  item_name = match.group(1)
                                  
                          elif "pub type " in pub_line:
                              item_type = "type"
                              match = re.search(r'type\s+([a-zA-Z0-9_]+)', pub_line)
                              if match:
                                  item_name = match.group(1)
                                  
                          elif "pub mod " in pub_line:
                              item_type = "mod"
                              match = re.search(r'mod\s+([a-zA-Z0-9_]+)', pub_line)
                              if match:
                                  item_name = match.group(1)
                                  
                          # Extract signature for non-struct/enum items
                          if item_name and item_type not in ["struct", "enum"]:
                              signature, next_line = extract_item_signature(lines, next_i)
                              
                              items.append({
                                  "type": item_type,
                                  "name": item_name,
                                  "doc": doc_comment,
                                  "signature": signature
                              })
                              
                              i = next_line
                              continue
                      
                      # If we process the doc comment but didn't create an item,
                      # continue from where the doc comment ended
                      i = next_i
                      continue
                  
                  # Check for public items without doc comments
                  elif line.startswith("pub ") and not line.startswith("pub use"):
                      # Similar logic as above, but for undocumented items
                      pub_line = line
                      
                      # Determine item type and name
                      item_type, item_name = "item", ""
                      fields = []
                      
                      if "pub struct " in pub_line:
                          item_type = "struct"
                          match = re.search(r'struct\s+([a-zA-Z0-9_]+)', pub_line)
                          if match:
                              item_name = match.group(1)
                              
                              # Extract signature with a reasonable amount of fields
                              signature, field_end = extract_item_signature(lines, i)
                              
                              # Extract field documentation
                              fields, _ = extract_struct_fields(lines, i)
                              
                              items.append({
                                  "type": item_type,
                                  "name": item_name,
                                  "doc": "",
                                  "signature": signature,
                                  "fields": fields
                              })
                              
                              i = field_end
                              continue
                      
                      elif "pub enum " in pub_line:
                          item_type = "enum"
                          match = re.search(r'enum\s+([a-zA-Z0-9_]+)', pub_line)
                          if match:
                              item_name = match.group(1)
                              
                              # Extract signature with a reasonable amount of variants
                              signature, variant_end = extract_item_signature(lines, i)
                              
                              # Extract variant documentation
                              fields, _ = extract_enum_variants(lines, i)
                              
                              items.append({
                                  "type": item_type,
                                  "name": item_name,
                                  "doc": "",
                                  "signature": signature,
                                  "fields": fields
                              })
                              
                              i = variant_end
                              continue
                      
                      # Other item types (traits, functions, etc.)
                      elif "pub trait " in pub_line:
                          item_type = "trait"
                          match = re.search(r'trait\s+([a-zA-Z0-9_]+)', pub_line)
                          if match:
                              item_name = match.group(1)
                      
                      elif "pub async fn " in pub_line:
                          item_type = "async fn"
                          match = re.search(r'async\s+fn\s+([a-zA-Z0-9_]+)', pub_line)
                          if match:
                              item_name = match.group(1)
                      
                      elif "pub fn " in pub_line:
                          item_type = "fn"
                          match = re.search(r'fn\s+([a-zA-Z0-9_]+)', pub_line)
                          if match:
                              item_name = match.group(1)
                      
                      # Extract signature for non-struct/enum items
                      if item_name and item_type not in ["struct", "enum"]:
                          signature, next_line = extract_item_signature(lines, i)
                          
                          items.append({
                              "type": item_type,
                              "name": item_name,
                              "doc": "",
                              "signature": signature
                          })
                          
                          i = next_line
                          continue
                  
                  # Move to next line if we didn't process this one
                  i += 1
              
              return items
          
          def format_doc_comment(text):
              """Format documentation with proper markdown"""
              # Fix headers - ensure # headings start on their own line
              text = re.sub(r'([^\n])# ([A-Z][a-zA-Z ]+)', r'\1\n\n## \2', text)
              
              # Ensure proper spacing around lists
              text = re.sub(r'([^\n])(\n\*)', r'\1\n\n\2', text)
              
              # Fix spacing in paragraphs
              text = re.sub(r'\.([A-Z])', r'. \1', text)
              
              # Ensure backticks for code references
              text = re.sub(r' ([a-zA-Z0-9_]+)\(\)', r' `\1()`', text)
              
              # Ensure proper spacing between paragraphs
              paragraphs = re.split(r'\n{2,}', text)
              return "\n\n".join(p.strip() for p in paragraphs if p.strip())
          
          if __name__ == "__main__":
              sys.exit(main())
          EOF
          
          # Make script executable
          chmod +x extract_docs.py

      - name: Generate Wiki Documentation
        run: |
          # Run the doc extraction script
          python3 extract_docs.py src wiki-content

      - name: Setup Git for Wiki
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Clone Wiki Repository
        run: |
          # Use PAT for wiki push
          git clone https://${{ secrets.WIKI_TOKEN }}@github.com/${{ github.repository }}.wiki.git wiki-repo
          
          # Copy content to wiki
          cp -r wiki-content/* wiki-repo/
          
          cd wiki-repo
          git add .
          
          # Commit if changes exist
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update documentation from Rust code (${GITHUB_SHA:0:7})"
            git push
          fi

      - name: Upload Markdown as artifact
        uses: actions/upload-artifact@v4
        with:
          name: wiki-docs
          path: wiki-content/
