name: Rust Docs to Wiki

# This workflow extracts documentation from Rust source code and updates the GitHub wiki.
# 
# IMPORTANT: This workflow requires a personal access token (PAT) with 'workflow' scope
# to push changes to the wiki repository. The default GITHUB_TOKEN doesn't have wiki permissions.
# 
# Setup instructions:
# 1. Create a personal access token with 'workflow' scope at:
#    https://github.com/settings/tokens
# 2. Add the token as a repository secret named 'WIKI_TOKEN' at:
#    https://github.com/YOUR_USERNAME/YOUR_REPO/settings/secrets/actions

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*.rs'
      - 'Cargo.toml'
      - '.github/workflows/rust-docs-to-wiki.yml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  extract-docs-and-update-wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable

      - name: Generate documentation
        run: |
          # Create directory for wiki content
          mkdir -p wiki-content
          
          # Create Home.md
          echo "# ${GITHUB_REPOSITORY#*/} Documentation" > wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "This wiki contains automatically generated documentation from the Rust codebase." >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "## Modules" >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          
          # Process each source file with guaranteed unique filenames
          find src -name "*.rs" -type f | while read -r file; do
            # Get file info
            base_name=$(basename "$file" .rs)
            dir_path=$(dirname "$file")
            
            # Convert path to a unique filename by replacing slashes with underscores
            unique_name=$(echo "${dir_path//\//_}_${base_name}" | sed 's/^src_//')
            output_file="wiki-content/${unique_name}.md"
            
            echo "# $base_name ($dir_path)" > "$output_file"
            echo "" >> "$output_file"
            echo "Path: \`$file\`" >> "$output_file"
            echo "" >> "$output_file"
            
            # Generate table of contents header
            echo "## Table of Contents" >> "$output_file"
            echo "" >> "$output_file"
            
            # Collect all public items for table of contents
            grep -n "^pub " "$file" | while read -r toc_line; do
              line_num=$(echo "$toc_line" | cut -d: -f1)
              item=$(echo "$toc_line" | cut -d: -f2-)
              
              # Check if there are doc comments above
              doc_comment_lines=$(head -n $((line_num-1)) "$file" | tac | grep -m 1 -A 100 "^///" | tac)
              if [ -n "$doc_comment_lines" ]; then
                item_name=$(echo "$item" | sed 's/pub //' | sed 's/{.*//' | sed 's/(.*//' | tr -d '\n')
                echo "* [$item_name](#${item_name// /-})" >> "$output_file"
              fi
            done
            
            echo "" >> "$output_file"
            
            # Extract module-level documentation (//! comments)
            module_docs=$(grep -A 5 "//!" "$file" | sed 's/\/\/\!\s*//' | sed '/^--$/d')
            if [ -n "$module_docs" ]; then
              echo "## Module Documentation" >> "$output_file"
              echo "" >> "$output_file"
              echo "$module_docs" >> "$output_file"
              echo "" >> "$output_file"
            fi
            
            # Add section for public items
            echo "# Public Items" >> "$output_file"
            echo "" >> "$output_file"
            
            # Extract function/struct/trait names and doc comments
            grep -n "^pub " "$file" | while read -r line; do
              line_num=$(echo "$line" | cut -d: -f1)
              item=$(echo "$line" | cut -d: -f2-)
              
              # Find the continuous block of doc comments above this item
              start_line=1
              end_line=$((line_num-1))
              
              # Find where the doc comments start
              found_comments=0
              for ((i=line_num-1; i>=1; i--)); do
                content=$(sed -n "${i}p" "$file")
                if echo "$content" | grep -q "^///"; then
                  found_comments=1
                  start_line=$i
                elif [ $found_comments -eq 1 ]; then
                  # We've found the first non-doc-comment line after finding comments
                  start_line=$((i+1))
                  break
                fi
              done
              
              # If we found doc comments, extract and format them
              if [ $found_comments -eq 1 ]; then
                # Extract the full function/type signature
                item_name=$(echo "$item" | sed 's/pub //' | sed 's/{.*//' | sed 's/(.*//' | tr -d '\n')
                
                # Find the end of the signature (either { or ; or where)
                sig_start_line=$line_num
                sig_end_line=$sig_start_line
                
                # For function signatures that span multiple lines
                for ((i=line_num; i<$(wc -l < "$file"); i++)); do
                  content=$(sed -n "${i}p" "$file")
                  sig_end_line=$i
                  if echo "$content" | grep -q "{" || echo "$content" | grep -q ";" || echo "$content" | grep -q "where"; then
                    break
                  fi
                done
                
                # Extract the full signature
                full_sig=$(sed -n "${sig_start_line},${sig_end_line}p" "$file")
                
                # Write the function/item name and signature
                echo "## $item_name" >> "$output_file"
                echo "" >> "$output_file"
                echo '```rust' >> "$output_file"
                echo "$full_sig" >> "$output_file"
                echo '```' >> "$output_file"
                echo "" >> "$output_file"
                
                # Extract and format the doc comments
                doc_comments=$(sed -n "${start_line},${end_line}p" "$file" | sed 's/^\/\/\/ *//')
                
                # Convert Rust doc headings to markdown headings
                processed_comments=$(echo "$doc_comments" | 
                  # Convert "# Arguments" style headings to markdown h3
                  sed 's/^# \(.*\)$/### \1/' |
                  # Handle other standard Rust doc headings
                  sed '/^###/!s/^#\s*Arguments$/### Arguments/' |
                  sed '/^###/!s/^#\s*Parameters$/### Parameters/' |
                  sed '/^###/!s/^#\s*Returns$/### Returns/' |
                  sed '/^###/!s/^#\s*Examples$/### Examples/' |
                  sed '/^###/!s/^#\s*Note$/### Note/' |
                  sed '/^###/!s/^#\s*Notes$/### Notes/' |
                  sed '/^###/!s/^#\s*Error Handling$/### Error Handling/' |
                  sed '/^###/!s/^#\s*Warning$/### Warning/' |
                  sed '/^###/!s/^#\s*Use Cases$/### Use Cases/' |
                  sed '/^###/!s/^#\s*Pagination$/### Pagination/' |
                  sed '/^###/!s/^#\s*Important$/### Important/' |
                  sed '/^###/!s/^#\s*Transaction Handling$/### Transaction Handling/' |
                  sed '/^###/!s/^#\s*State Model$/### State Model/' |
                  sed '/^###/!s/^#\s*Status Model$/### Status Model/')
                
                echo "$processed_comments" >> "$output_file"
                echo "" >> "$output_file"
              fi
            done
            
            # Add a link to the home page
            echo "* [$unique_name]($unique_name)" >> wiki-content/Home.md
          done

      - name: Setup Git for Wiki
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Clone Wiki Repository
        run: |
          # Use PAT for wiki push (needs to be set in repository secrets)
          git clone https://${{ secrets.WIKI_TOKEN }}@github.com/${{ github.repository }}.wiki.git wiki-repo
          
          # Copy new content to wiki repository
          cp -r wiki-content/* wiki-repo/
          
          cd wiki-repo
          git add .
          
          # Only commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update documentation from Rust code (${GITHUB_SHA:0:7})"
            git push
          fi

      - name: Upload Markdown as artifact
        uses: actions/upload-artifact@v4
        with:
          name: wiki-docs
          path: wiki-content/
