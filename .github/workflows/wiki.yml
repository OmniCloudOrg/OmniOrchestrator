name: Rust Docs to Wiki Generator

# This workflow extracts documentation from Rust source code files and generates
# a comprehensive wiki with proper documentation for all types of Rust items.
#
# Features:
# - Extracts module-level documentation (//! comments)
# - Processes doc comments for all public items (/// comments)
# - Handles struct, enum, trait, function, and other types
# - Preserves markdown formatting in documentation
# - Creates clean, well-formatted wiki pages

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*.rs'
      - 'Cargo.toml'
      - '.github/workflows/rust-docs-to-wiki.yml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  generate-wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable

      - name: Create wiki directories
        run: |
          # Create directory for wiki content
          mkdir -p wiki-content
          
          # Create Home.md
          echo "# ${GITHUB_REPOSITORY#*/} Documentation" > wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "This wiki contains automatically generated documentation from the Rust codebase." >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "## Modules" >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md

      - name: Create rustdoc extractor
        run: |
          # This function-rich script processes Rust files and extracts documentation
          cat > rustdoc_extract.sh << 'EOF'
          #!/bin/bash
          
          # rustdoc_extract.sh - Extract documentation from Rust source files
          #
          # This script processes Rust source files and extracts documentation comments,
          # generating markdown files suitable for a GitHub wiki.
          
          # Exit on errors unless caught with ||
          set -eo pipefail
          
          # Print how to use this script
          function print_usage() {
            echo "Usage: $0 <source_dir> <output_dir>"
            echo ""
            echo "Arguments:"
            echo "  source_dir   Directory containing Rust source files"
            echo "  output_dir   Directory where wiki pages will be created"
          }
          
          # Process markdown text to improve formatting
          function improve_markdown_formatting() {
            local text="$1"
            
            # Replace contiguous spaces with newlines
            # This preserves paragraph breaks from the original doc comment
            text=$(echo "$text" | sed 's/\\n\\n/\n\n/g')
            
            # Convert # Arguments to ## Arguments (add a level)
            text=$(echo "$text" | sed 's/^# Arguments$/\n## Arguments/')
            text=$(echo "$text" | sed 's/^# Returns$/\n## Returns/')
            text=$(echo "$text" | sed 's/^# Error Handling$/\n## Error Handling/')
            text=$(echo "$text" | sed 's/^# Note$/\n## Note/')
            text=$(echo "$text" | sed 's/^# Notes$/\n## Notes/')
            text=$(echo "$text" | sed 's/^# Warning$/\n## Warning/')
            text=$(echo "$text" | sed 's/^# Examples$/\n## Examples/')
            text=$(echo "$text" | sed 's/^# Use Cases$/\n## Use Cases/')
            text=$(echo "$text" | sed 's/^# Pagination$/\n## Pagination/')
            text=$(echo "$text" | sed 's/^# Status Lifecycle$/\n## Status Lifecycle/')
            text=$(echo "$text" | sed 's/^# Transaction Handling$/\n## Transaction Handling/')
            text=$(echo "$text" | sed 's/^# Relationships$/\n## Relationships/')
            
            # Fix list items that may have been merged into paragraphs
            text=$(echo "$text" | sed 's/\([^*]\)\* /\1\n* /g')
            
            # Fix spacing in paragraphs (ensure there's a space after each sentence)
            text=$(echo "$text" | sed 's/\.\([A-Z]\)/. \1/g')
            
            echo "$text"
          }
          
          # Extract module-level documentation (//! comments)
          function extract_module_docs() {
            local file="$1"
            local output_file="$2"
            
            echo "Extracting module documentation from $file"
            
            # Find all //! comments
            grep -n "^[[:space:]]*//!" "$file" | while read -r line_info; do
              # Extract line number and content
              line_num=$(echo "$line_info" | cut -d: -f1)
              line_content=$(echo "$line_info" | cut -d: -f2-)
              
              # Remove //! prefix and leading whitespace
              comment=$(echo "$line_content" | sed 's/^[[:space:]]*\/\/![[:space:]]*//')
              
              # Write to output
              echo "$comment" >> "$output_file.module_docs"
            done || true  # Don't fail if grep finds nothing
            
            # If we found module docs, add them to the wiki page
            if [ -f "$output_file.module_docs" ] && [ -s "$output_file.module_docs" ]; then
              echo "## Module Documentation" >> "$output_file"
              echo "" >> "$output_file"
              
              # Improve formatting and add to output
              local formatted_docs=$(improve_markdown_formatting "$(cat "$output_file.module_docs")")
              echo "$formatted_docs" >> "$output_file"
              echo "" >> "$output_file"
              
              rm "$output_file.module_docs"
            fi
          }
          
          # Create a table of contents based on public items
          function generate_table_of_contents() {
            local file="$1"
            local output_file="$2"
            
            echo "Generating table of contents for $file"
            
            echo "## Table of Contents" >> "$output_file"
            echo "" >> "$output_file"
            
            # Create a temporary file with all public items
            grep -n "^[[:space:]]*pub " "$file" > "$output_file.toc_items" || true
            
            # Process each item
            if [ -f "$output_file.toc_items" ] && [ -s "$output_file.toc_items" ]; then
              while read -r line_info; do
                # Extract line number and content
                line_num=$(echo "$line_info" | cut -d: -f1)
                line_content=$(echo "$line_info" | cut -d: -f2-)
                
                # Determine item type and name
                if [[ "$line_content" =~ pub[[:space:]]+struct[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="struct"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+enum[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="enum"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+trait[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="trait"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+fn[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="fn"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+async[[:space:]]+fn[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="async fn"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+type[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="type"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+mod[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="mod"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+const[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="const"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+use[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="use"
                  item_name="${BASH_REMATCH[1]}"
                else
                  # Handle any other pub item
                  item_type="item"
                  item_name=$(echo "$line_content" | sed 's/^[[:space:]]*pub[[:space:]]*\([^{; ]*\).*/\1/' || echo "unknown")
                fi
                
                # If we identified the item, add it to TOC
                if [ -n "$item_name" ] && [ "$item_name" != "unknown" ]; then
                  anchor=$(echo "$item_name" | tr '[:upper:]' '[:lower:]')
                  echo "* [$item_type $item_name](#$anchor)" >> "$output_file"
                fi
              done < "$output_file.toc_items"
              
              echo "" >> "$output_file"
            else
              echo "No public items found" >> "$output_file"
              echo "" >> "$output_file"
            fi
            
            rm -f "$output_file.toc_items"
          }
          
          # Extract doc comment block into a temporary file
          function extract_doc_comment_block() {
            local file="$1"
            local line_num="$2"
            local output_file="$3"
            
            # Create empty output
            > "$output_file"
            
            # Go backward to find the start of the doc comment block
            local current_line=$((line_num - 1))
            local in_comment=false
            local comment_lines=()
            
            # Collect lines in reverse order first
            while [ $current_line -ge 1 ]; do
              local line=$(sed -n "${current_line}p" "$file")
              
              if [[ "$line" =~ ^[[:space:]]*\/\/\/ ]]; then
                # Extract comment content
                local comment=$(echo "$line" | sed 's/^[[:space:]]*\/\/\/[[:space:]]*//')
                comment_lines=("$comment" "${comment_lines[@]}")
                in_comment=true
              elif [[ "$line" =~ ^[[:space:]]*$ ]] && [ "$in_comment" = true ]; then
                # Keep empty lines within comments
                comment_lines=("" "${comment_lines[@]}")
              else
                # Stop when we hit a non-comment, non-empty line
                break
              fi
              
              current_line=$((current_line - 1))
            done
            
            # Write the collected comment lines in correct order
            for comment in "${comment_lines[@]}"; do
              echo "$comment" >> "$output_file"
            done
          }
          
          # Process doc comments (///) and associate them with public items
          function extract_documented_items() {
            local file="$1"
            local output_file="$2"
            
            echo "Extracting documented items from $file"
            
            echo "## Public Items" >> "$output_file"
            echo "" >> "$output_file"
            
            # Find lines with public items
            grep -n "^[[:space:]]*pub " "$file" > "$output_file.pub_items" || true
            
            if [ -f "$output_file.pub_items" ] && [ -s "$output_file.pub_items" ]; then
              while read -r line_info; do
                # Extract line number and content
                line_num=$(echo "$line_info" | cut -d: -f1)
                line_content=$(echo "$line_info" | cut -d: -f2-)
                
                # Extract doc comments for this item
                extract_doc_comment_block "$file" "$line_num" "$output_file.doc_block"
                
                # Check if we have doc comments
                if [ -s "$output_file.doc_block" ]; then
                  # Determine item type and name
                  local item_type=""
                  local item_name=""
                  
                  if [[ "$line_content" =~ pub[[:space:]]+struct[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                    item_type="struct"
                    item_name="${BASH_REMATCH[1]}"
                  elif [[ "$line_content" =~ pub[[:space:]]+enum[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                    item_type="enum"
                    item_name="${BASH_REMATCH[1]}"
                  elif [[ "$line_content" =~ pub[[:space:]]+trait[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                    item_type="trait"
                    item_name="${BASH_REMATCH[1]}"
                  elif [[ "$line_content" =~ pub[[:space:]]+fn[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                    item_type="fn"
                    item_name="${BASH_REMATCH[1]}"
                  elif [[ "$line_content" =~ pub[[:space:]]+async[[:space:]]+fn[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                    item_type="async fn"
                    item_name="${BASH_REMATCH[1]}"
                  elif [[ "$line_content" =~ pub[[:space:]]+type[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                    item_type="type"
                    item_name="${BASH_REMATCH[1]}"
                  elif [[ "$line_content" =~ pub[[:space:]]+mod[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                    item_type="mod"
                    item_name="${BASH_REMATCH[1]}"
                  elif [[ "$line_content" =~ pub[[:space:]]+const[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                    item_type="const"
                    item_name="${BASH_REMATCH[1]}"
                  elif [[ "$line_content" =~ pub[[:space:]]+use[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                    item_type="use"
                    item_name="${BASH_REMATCH[1]}"
                  else
                    # Handle any other pub item
                    item_type="item"
                    item_name=$(echo "$line_content" | sed 's/^[[:space:]]*pub[[:space:]]*\([^{; ]*\).*/\1/' || echo "unknown")
                  fi
                  
                  # Add item to the wiki
                  if [ -n "$item_name" ] && [ "$item_name" != "unknown" ]; then
                    echo "### $item_type $item_name" >> "$output_file"
                    echo "" >> "$output_file"
                    
                    # Format and add doc comments
                    cat "$output_file.doc_block" | awk '{
                      # Check if this line starts a new paragraph
                      if ($0 ~ /^$/ && prev_empty == 0) {
                        print "";  # Print a blank line for paragraph break
                        prev_empty = 1;
                      } 
                      # Check if this is a list item
                      else if ($0 ~ /^\* /) {
                        # Ensure list items have a blank line before them if needed
                        if (prev_empty == 0 && !first_line) {
                          print "";
                        }
                        print $0;
                        prev_empty = 0;
                      }
                      # Regular content line
                      else if ($0 !~ /^$/) {
                        print $0;
                        prev_empty = 0;
                      }
                      first_line = 0;
                    }' >> "$output_file"
                    echo "" >> "$output_file"
                    
                    # Add code signature
                    echo '```rust' >> "$output_file"
                    echo "$line_content" >> "$output_file"
                    
                    # Extract more of the signature if needed
                    if [[ ! "$line_content" =~ [;{][[:space:]]*$ ]]; then
                      # Multi-line item, capture more
                      local next_line=$((line_num + 1))
                      local max_lines=10
                      local count=0
                      
                      while [ $count -lt $max_lines ]; do
                        local next_content=$(sed -n "${next_line}p" "$file" || echo "")
                        
                        # Skip empty lines and comments
                        if [[ "$next_content" =~ ^[[:space:]]*$ ]] || [[ "$next_content" =~ ^[[:space:]]*\/\/ ]]; then
                          next_line=$((next_line + 1))
                          continue
                        fi
                        
                        echo "$next_content" >> "$output_file"
                        count=$((count + 1))
                        
                        # Stop at end of signature
                        if [[ "$next_content" =~ [;{][[:space:]]*$ ]]; then
                          if [[ "$next_content" =~ [{][[:space:]]*$ ]]; then
                            echo "    // ... implementation" >> "$output_file"
                            echo "}" >> "$output_file"
                          fi
                          break
                        fi
                        
                        next_line=$((next_line + 1))
                      done
                      
                      # If we didn't find the end, add an ellipsis
                      if [ $count -eq $max_lines ]; then
                        echo "    // ..." >> "$output_file"
                      fi
                    fi
                    
                    echo '```' >> "$output_file"
                    echo "" >> "$output_file"
                  fi
                fi
              done < "$output_file.pub_items"
            else
              echo "No documented public items found." >> "$output_file"
              echo "" >> "$output_file"
            fi
            
            # Clean up
            rm -f "$output_file.pub_items"
            rm -f "$output_file.doc_block"
          }
          
          # Safely process a Rust file with error handling
          function safe_process_rust_file() {
            local file="$1"
            local output_dir="$2"
            
            # Create unique filename for wiki page
            local base_name=$(basename "$file" .rs)
            local dir_path=$(dirname "$file")
            local unique_name=$(echo "${dir_path//\//_}_${base_name}" | sed 's/^src_//')
            local output_file="$output_dir/${unique_name}.md"
            
            echo "Processing $file"
            
            # Create page header
            echo "# $base_name ($dir_path)" > "$output_file"
            echo "" >> "$output_file"
            echo "Path: \`$file\`" >> "$output_file"
            echo "" >> "$output_file"
            
            # Extract documentation sections with error handling
            extract_module_docs "$file" "$output_file" || echo "Warning: Error extracting module docs from $file"
            generate_table_of_contents "$file" "$output_file" || echo "Warning: Error generating TOC for $file"
            extract_documented_items "$file" "$output_file" || echo "Warning: Error extracting documented items from $file"
            
            # Add link to Home.md
            echo "* [$unique_name](${unique_name})" >> "$output_dir/Home.md"
            
            echo "Completed processing $file -> $output_file"
          }
          
          # Main processing function
          function process_all_rust_files() {
            local source_dir="$1"
            local output_dir="$2"
            
            # Find all Rust files
            find "$source_dir" -name "*.rs" -type f | while read -r file; do
              safe_process_rust_file "$file" "$output_dir" || echo "Error processing $file, continuing with next file"
            done
          }
          
          # Script entry point
          if [ "$#" -lt 2 ]; then
            print_usage
            exit 1
          fi
          
          source_dir="$1"
          output_dir="$2"
          
          # Validate directories
          if [ ! -d "$source_dir" ]; then
            echo "Error: Source directory does not exist: $source_dir"
            exit 1
          fi
          
          if [ ! -d "$output_dir" ]; then
            echo "Error: Output directory does not exist: $output_dir"
            exit 1
          fi
          
          # Process all Rust files
          echo "Starting documentation extraction from $source_dir to $output_dir"
          process_all_rust_files "$source_dir" "$output_dir"
          echo "Documentation extraction complete!"
          
          # Return success
          exit 0
          EOF
          
          # Make script executable
          chmod +x rustdoc_extract.sh

      - name: Generate Wiki Documentation
        run: |
          # Run the doc extraction script
          ./rustdoc_extract.sh src wiki-content

      - name: Setup Git for Wiki
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Clone Wiki Repository
        run: |
          # Use PAT for wiki push
          git clone https://${{ secrets.WIKI_TOKEN }}@github.com/${{ github.repository }}.wiki.git wiki-repo
          
          # Copy content to wiki
          cp -r wiki-content/* wiki-repo/
          
          cd wiki-repo
          git add .
          
          # Commit if changes exist
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update documentation from Rust code (${GITHUB_SHA:0:7})"
            git push
          fi

      - name: Upload Markdown as artifact
        uses: actions/upload-artifact@v4
        with:
          name: wiki-docs
          path: wiki-content/
