name: Rust Docs to Wiki with cargo-readme

# This workflow uses cargo-readme to extract documentation from Rust source files
# and update the GitHub wiki repository.

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*.rs'
      - 'Cargo.toml'
      - '.github/workflows/rust-docs-to-wiki.yml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  extract-docs-and-update-wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable

      - name: Install cargo-readme
        run: |
          cargo install cargo-readme

      - name: Generate documentation
        run: |
          # Create directory for wiki content
          mkdir -p wiki-content
          
          # Create Home.md
          echo "# ${GITHUB_REPOSITORY#*/} Documentation" > wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "This wiki contains automatically generated documentation from the Rust codebase." >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "## Modules" >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          
          # Create template for cargo-readme
          cat > readme.tpl << 'EOF'
          # {{title}}

          Path: `{{file_path}}`

          {{readme}}
          EOF

          # Process each source file
          find src -name "*.rs" -type f | while read -r file; do
            # Get file info
            base_name=$(basename "$file" .rs)
            dir_path=$(dirname "$file")
            
            # Convert path to a unique filename by replacing slashes with underscores
            unique_name=$(echo "${dir_path//\//_}_${base_name}" | sed 's/^src_//')
            output_file="wiki-content/${unique_name}.md"
            
            echo "Processing $file into $output_file"
            
            # Create temporary cargo project to process the file
            temp_dir=$(mktemp -d)
            mkdir -p "$temp_dir/src"
            
            # Copy the file as lib.rs in the temp project
            cp "$file" "$temp_dir/src/lib.rs"
            
            # Create a minimal Cargo.toml
            cat > "$temp_dir/Cargo.toml" << EOF
            [package]
            name = "$base_name"
            version = "0.1.0"
            edition = "2021"
            
            [lib]
            path = "src/lib.rs"
            EOF
            
            # Generate the documentation
            (
              cd "$temp_dir"
              
              # Add custom variables to the template
              echo '{"title":"'"$base_name ($dir_path)"'","file_path":"'"$file"'"}' > readme_extra.json
              
              # Run cargo-readme with our template and extra variables
              cargo readme --template ../readme.tpl --output "$GITHUB_WORKSPACE/$output_file" --no-title --no-badge --no-license --json readme_extra.json
              
              # If cargo-readme fails (which can happen if file has no doc comments),
              # create a minimal doc file
              if [ $? -ne 0 ]; then
                echo "# $base_name ($dir_path)" > "$GITHUB_WORKSPACE/$output_file"
                echo "" >> "$GITHUB_WORKSPACE/$output_file"
                echo "Path: \`$file\`" >> "$GITHUB_WORKSPACE/$output_file"
                echo "" >> "$GITHUB_WORKSPACE/$output_file"
                echo "## Public Items" >> "$GITHUB_WORKSPACE/$output_file"
                echo "" >> "$GITHUB_WORKSPACE/$output_file"
                
                # Try to extract public items using grep
                grep -n "^pub " "$GITHUB_WORKSPACE/$file" | while read -r line; do
                  item=$(echo "$line" | cut -d: -f2-)
                  # Clean up and add to the file
                  cleaned_item=$(echo "$item" | sed 's/{.*//' | sed 's/(.*//')
                  echo "* \`$cleaned_item\`" >> "$GITHUB_WORKSPACE/$output_file"
                done
              fi
            )
            
            # Clean up
            rm -rf "$temp_dir"
            
            # Enhance the documentation with public item signatures
            # Create a section with all public items and their signatures
            echo "" >> "$output_file"
            echo "## Public API Reference" >> "$output_file"
            echo "" >> "$output_file"
            
            # Extract public items with their signatures
            awk '
            BEGIN {
              in_pub_item = 0;
              pub_item = "";
              brace_count = 0;
            }
            
            /^pub / {
              if (!in_pub_item) {
                in_pub_item = 1;
                pub_item = $0;
                brace_count = 0;
                
                # Count opening braces
                for (i = 1; i <= length($0); i++) {
                  if (substr($0, i, 1) == "{") brace_count++;
                  if (substr($0, i, 1) == "}") brace_count--;
                }
                
                # If single line item (ends with semicolon or has balanced braces)
                if ($0 ~ /;$/ || brace_count == 0) {
                  print "### " $0;
                  print "";
                  print "```rust";
                  print pub_item;
                  print "```";
                  print "";
                  in_pub_item = 0;
                }
              }
              next;
            }
            
            # Continue collecting multi-line pub item
            in_pub_item {
              pub_item = pub_item "\n" $0;
              
              # Count braces
              for (i = 1; i <= length($0); i++) {
                if (substr($0, i, 1) == "{") brace_count++;
                if (substr($0, i, 1) == "}") brace_count--;
              }
              
              # If we have a balanced set of braces or end of definition
              if (brace_count == 0 || $0 ~ /;$/ || $0 ~ /}$/) {
                # Print truncated definition for readability if too long
                print "### " substr(pub_item, 5, 50) (length(pub_item) > 55 ? "..." : "");
                print "";
                print "```rust";
                # For struct/enum with large bodies, only show the declaration part
                if (pub_item ~ /^pub (struct|enum|trait)/ && brace_count == 0) {
                  split_at = index(pub_item, "{");
                  if (split_at > 0) {
                    # Show declaration plus opening brace
                    print substr(pub_item, 1, split_at) " ... }";
                  } else {
                    print pub_item;
                  }
                } else {
                  print pub_item;
                }
                print "```";
                print "";
                in_pub_item = 0;
              }
            }
            ' "$file" >> "$output_file"
            
            # Add a link to the home page
            echo "* [$unique_name](${unique_name})" >> wiki-content/Home.md
          done

      - name: Setup Git for Wiki
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Clone Wiki Repository
        run: |
          # Use PAT for wiki push (needs to be set in repository secrets)
          git clone https://${{ secrets.WIKI_TOKEN }}@github.com/${{ github.repository }}.wiki.git wiki-repo
          
          # Copy new content to wiki repository
          cp -r wiki-content/* wiki-repo/
          
          cd wiki-repo
          git add .
          
          # Only commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update documentation from Rust code (${GITHUB_SHA:0:7})"
            git push
          fi

      - name: Upload Markdown as artifact
        uses: actions/upload-artifact@v4
        with:
          name: wiki-docs
          path: wiki-content/
