name: Rust Docs to Wiki

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*.rs'
      - 'Cargo.toml'
      - '.github/workflows/rust-docs-to-wiki.yml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  extract-docs-and-update-wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create wiki directories
        run: |
          # Create directory for wiki content
          mkdir -p wiki-content
          
          # Create Home.md
          echo "# ${GITHUB_REPOSITORY#*/} Documentation" > wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "This wiki contains automatically generated documentation from the Rust codebase." >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "## Modules" >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md

      - name: Extract Documentation - Basic Method
        run: |
          # Process each source file - ultra simple approach
          find src -name "*.rs" -type f | while read -r file; do
            # Get file info
            base_name=$(basename "$file" .rs)
            dir_path=$(dirname "$file")
            
            # Create unique filename
            unique_name=$(echo "${dir_path//\//_}_${base_name}" | sed 's/^src_//')
            output_file="wiki-content/${unique_name}.md"
            
            echo "Processing $file into $output_file"
            
            # Create file header
            echo "# $base_name ($dir_path)" > "$output_file"
            echo "" >> "$output_file"
            echo "Path: \`$file\`" >> "$output_file"
            echo "" >> "$output_file"
            
            # Extract module docs (//!)
            grep -B 1 -A 1 "^//!" "$file" | grep -v "^--$" > module_docs.txt
            if [ -s module_docs.txt ]; then
              echo "## Module Documentation" >> "$output_file"
              echo "" >> "$output_file"
              cat module_docs.txt | sed 's/^\/\/!\s*//' >> "$output_file"
              echo "" >> "$output_file"
            fi
            rm -f module_docs.txt
            
            # Add section for documented items
            echo "## Documentation" >> "$output_file"
            echo "" >> "$output_file"
            
            # Extract all doc comments and the lines immediately following them
            # The approach: Capture every sequence of /// comments followed by any non-comment line
            awk '
            BEGIN { in_doc = 0; doc_block = ""; item = ""; }
            
            # Doc comment line
            /^[[:space:]]*\/\/\// { 
                in_doc = 1; 
                # Remove /// prefix and add to block
                sub(/^[[:space:]]*\/\/\/[[:space:]]*/, "");
                doc_block = doc_block $0 "\n";
                next;
            }
            
            # Empty line while in doc block - keep it
            /^[[:space:]]*$/ && in_doc { 
                doc_block = doc_block "\n";
                next;
            }
            
            # Non-doc, non-empty line after doc block - this is the item
            in_doc && !/^[[:space:]]*$/ && !/^[[:space:]]*\/\/\// {
                # This is the item definition
                item = $0;
                
                # Print only if item starts with pub
                if ($0 ~ /^[[:space:]]*pub/) {
                    # Try to get an item type/name for the header
                    header = "Item";
                    if ($0 ~ /struct[[:space:]][a-zA-Z0-9_]+/) {
                        match($0, /struct[[:space:]]+([a-zA-Z0-9_]+)/, arr);
                        header = "struct " arr[1];
                    } else if ($0 ~ /enum[[:space:]][a-zA-Z0-9_]+/) {
                        match($0, /enum[[:space:]]+([a-zA-Z0-9_]+)/, arr);
                        header = "enum " arr[1];
                    } else if ($0 ~ /fn[[:space:]][a-zA-Z0-9_]+/) {
                        match($0, /fn[[:space:]]+([a-zA-Z0-9_]+)/, arr);
                        header = "fn " arr[1];
                    } else if ($0 ~ /trait[[:space:]][a-zA-Z0-9_]+/) {
                        match($0, /trait[[:space:]]+([a-zA-Z0-9_]+)/, arr);
                        header = "trait " arr[1];
                    } else if ($0 ~ /type[[:space:]][a-zA-Z0-9_]+/) {
                        match($0, /type[[:space:]]+([a-zA-Z0-9_]+)/, arr);
                        header = "type " arr[1];
                    }
                    
                    print "### " header;
                    print "";
                    print doc_block;
                    print "";
                    print "```rust";
                    print item;
                    print "```";
                    print "";
                }
                
                # Reset for next block
                in_doc = 0;
                doc_block = "";
                item = "";
                next;
            }
            
            # Any other line - reset doc state
            { 
                in_doc = 0; 
                doc_block = ""; 
                item = "";
            }
            ' "$file" >> "$output_file"
            
            # Add a section for all public items regardless of documentation
            echo "## Public API" >> "$output_file"
            echo "" >> "$output_file"
            
            # Simply extract all lines starting with pub
            grep -n "^pub " "$file" | while read -r line_info; do
              line_num=$(echo "$line_info" | cut -d: -f1)
              item=$(echo "$line_info" | cut -d: -f2-)
              
              # Try to determine item type
              item_name="Item"
              if [[ "$item" =~ struct\ ([a-zA-Z0-9_]+) ]]; then
                item_name="struct ${BASH_REMATCH[1]}"
              elif [[ "$item" =~ enum\ ([a-zA-Z0-9_]+) ]]; then
                item_name="enum ${BASH_REMATCH[1]}"
              elif [[ "$item" =~ fn\ ([a-zA-Z0-9_]+) ]]; then
                item_name="fn ${BASH_REMATCH[1]}"
              elif [[ "$item" =~ trait\ ([a-zA-Z0-9_]+) ]]; then
                item_name="trait ${BASH_REMATCH[1]}"
              elif [[ "$item" =~ type\ ([a-zA-Z0-9_]+) ]]; then
                item_name="type ${BASH_REMATCH[1]}"
              fi
              
              # Add to wiki
              echo "### $item_name" >> "$output_file"
              echo "" >> "$output_file"
              echo "```rust" >> "$output_file"
              echo "$item" >> "$output_file"
              echo "```" >> "$output_file"
              echo "" >> "$output_file"
            done
            
            # Add link to Home.md
            echo "* [$unique_name](${unique_name})" >> wiki-content/Home.md
          done

      - name: Setup Git for Wiki
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Clone Wiki Repository
        run: |
          # Use PAT for wiki push
          git clone https://${{ secrets.WIKI_TOKEN }}@github.com/${{ github.repository }}.wiki.git wiki-repo
          
          # Copy content to wiki
          cp -r wiki-content/* wiki-repo/
          
          cd wiki-repo
          git add .
          
          # Commit if changes exist
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update documentation from Rust code (${GITHUB_SHA:0:7})"
            git push
          fi

      - name: Upload Markdown as artifact
        uses: actions/upload-artifact@v4
        with:
          name: wiki-docs
          path: wiki-content/
