name: Rust Docs to Wiki

# This workflow extracts documentation from Rust source code and updates the GitHub wiki.
# 
# IMPORTANT: This workflow requires a personal access token (PAT) with 'workflow' scope
# to push changes to the wiki repository. The default GITHUB_TOKEN doesn't have wiki permissions.
# 
# Setup instructions:
# 1. Create a personal access token with 'workflow' scope at:
#    https://github.com/settings/tokens
# 2. Add the token as a repository secret named 'WIKI_TOKEN' at:
#    https://github.com/YOUR_USERNAME/YOUR_REPO/settings/secrets/actions

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*.rs'
      - 'Cargo.toml'
      - '.github/workflows/rust-docs-to-wiki.yml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  extract-docs-and-update-wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable

      - name: Generate documentation
        run: |
          # Create directory for wiki content
          mkdir -p wiki-content
          
          # Create Home.md
          echo "# ${GITHUB_REPOSITORY#*/} Documentation" > wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "This wiki contains automatically generated documentation from the Rust codebase." >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "## Modules" >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          
          # Process each source file with guaranteed unique filenames
          find src -name "*.rs" -type f | while read -r file; do
            # Get file info
            base_name=$(basename "$file" .rs)
            dir_path=$(dirname "$file")
            
            # Convert path to a unique filename by replacing slashes with underscores
            unique_name=$(echo "${dir_path//\//_}_${base_name}" | sed 's/^src_//')
            output_file="wiki-content/${unique_name}.md"
            
            echo "# $base_name ($dir_path)" > "$output_file"
            echo "" >> "$output_file"
            echo "Path: \`$file\`" >> "$output_file"
            echo "" >> "$output_file"
            
            # Generate table of contents header
            echo "## Table of Contents" >> "$output_file"
            echo "" >> "$output_file"
            
            # Collect all public items for table of contents
            toc_items=$(grep -n "^pub " "$file" | while read -r toc_line; do
              line_num=$(echo "$toc_line" | cut -d: -f1)
              item=$(echo "$toc_line" | cut -d: -f2-)
              
              # Get doc comments above this item
              prev_lines=$(head -n $((line_num-1)) "$file" | tac | sed -n '/\/\/\//p' | tac)
              
              if [ -n "$prev_lines" ]; then
                item_name=$(echo "$item" | sed 's/pub //' | sed 's/{.*//' | sed 's/(.*//' | tr -d '\n')
                echo "* [$item_name](#${item_name// /-})"
              fi
            done)
            
            echo "$toc_items" >> "$output_file"
            echo "" >> "$output_file"
            
            # Extract module-level documentation (//! comments)
            module_docs=$(grep -A 5 "//!" "$file" | sed 's/\/\/\!\s*//' | sed '/^--$/d')
            if [ -n "$module_docs" ]; then
              echo "## Module Documentation" >> "$output_file"
              echo "" >> "$output_file"
              echo "$module_docs" >> "$output_file"
              echo "" >> "$output_file"
            fi
            
            # Add section for public items
            echo "# Public Items" >> "$output_file"
            echo "" >> "$output_file"
            
            # Extract function/struct/trait names and doc comments
            grep -n "^pub " "$file" | while read -r line; do
              line_num=$(echo "$line" | cut -d: -f1)
              item=$(echo "$line" | cut -d: -f2-)
              
              # Get doc comments above this item (/// style comments)
              # This extracts only the continuous block of comments immediately preceding the function
              end_line=$((line_num-1))
              start_line=$end_line
              
              # Find the start of the doc comment block by going backwards until we find a non-comment line
              while [ $start_line -gt 1 ]; do
                prev_line=$((start_line-1))
                line_content=$(sed "${prev_line}q;d" "$file")
                if ! echo "$line_content" | grep -q "^///"; then
                  # Found a non-doc comment line
                  break
                fi
                start_line=$prev_line
              done
              
              # Extract the entire comment block
              prev_lines=$(sed -n "${start_line},${end_line}p" "$file")
              
              if [ -n "$prev_lines" ]; then
                # Extract the full function/type signature
                item_name=$(echo "$item" | sed 's/pub //' | sed 's/{.*//' | sed 's/(.*//' | tr -d '\n')
                
                # Find the end of the signature (either { or ; or where)
                start_line=$line_num
                end_line=$start_line
                
                # For function signatures that span multiple lines
                if ! echo "$item" | grep -q "{" && ! echo "$item" | grep -q ";" && ! echo "$item" | grep -q "where"; then
                  while [ $end_line -lt $(wc -l < "$file") ]; do
                    end_line=$((end_line + 1))
                    line_content=$(sed "${end_line}q;d" "$file")
                    
                    if echo "$line_content" | grep -q "{" || echo "$line_content" | grep -q ";" || echo "$line_content" | grep -q "where"; then
                      break
                    fi
                  done
                fi
                
                # Extract the full signature
                full_sig=$(sed -n "${start_line},${end_line}p" "$file")
                
                echo "## $item_name" >> "$output_file"
                echo "" >> "$output_file"
                echo '```rust' >> "$output_file"
                echo "$full_sig" >> "$output_file"
                echo '```' >> "$output_file"
                echo "" >> "$output_file"
                
                # Process doc comments with clear section formatting
                # Strip the /// prefix from all lines
                formatted_docs=$(echo -e "$prev_lines" | sed 's/^\/\/\/ //')
                
                # Convert Rust doc headings to markdown headings
                formatted_docs=$(echo "$formatted_docs" | 
                  # Convert "# Arguments" style Rust doc headings to markdown h3
                  sed 's/^# \(.*\)$/### \1/' |
                  # Handle special case headings without converting normal text with #
                  sed '/^###/!s/^#\s*Arguments$/### Arguments/' |
                  sed '/^###/!s/^#\s*Parameters$/### Parameters/' |
                  sed '/^###/!s/^#\s*Returns$/### Returns/' |
                  sed '/^###/!s/^#\s*Examples$/### Examples/' |
                  sed '/^###/!s/^#\s*Note$/### Note/' |
                  sed '/^###/!s/^#\s*Notes$/### Notes/' |
                  sed '/^###/!s/^#\s*Error Handling$/### Error Handling/' |
                  sed '/^###/!s/^#\s*Warning$/### Warning/' |
                  sed '/^###/!s/^#\s*Use Cases$/### Use Cases/' |
                  sed '/^###/!s/^#\s*Pagination$/### Pagination/' |
                  sed '/^###/!s/^#\s*Important$/### Important/' |
                  sed '/^###/!s/^#\s*Transaction Handling$/### Transaction Handling/' |
                  sed '/^###/!s/^#\s*State Model$/### State Model/' |
                  sed '/^###/!s/^#\s*Status Model$/### Status Model/')
                
                echo "$formatted_docs" >> "$output_file"
                echo "" >> "$output_file"
              fi
              fi
            done
            
            # Add a link to the home page
            echo "* [$unique_name]($unique_name)" >> wiki-content/Home.md
          done

      - name: Setup Git for Wiki
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Clone Wiki Repository
        run: |
          # Use PAT for wiki push (needs to be set in repository secrets)
          git clone https://${{ secrets.WIKI_TOKEN }}@github.com/${{ github.repository }}.wiki.git wiki-repo
          
          # Copy new content to wiki repository
          cp -r wiki-content/* wiki-repo/
          
          cd wiki-repo
          git add .
          
          # Only commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update documentation from Rust code (${GITHUB_SHA:0:7})"
            git push
          fi

      - name: Upload Markdown as artifact
        uses: actions/upload-artifact@v4
        with:
          name: wiki-docs
          path: wiki-content/
