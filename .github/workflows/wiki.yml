name: Rust Docs to Wiki with cargo-readme

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*.rs'
      - 'Cargo.toml'
      - '.github/workflows/rust-docs-to-wiki.yml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  extract-docs-and-update-wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable

      - name: Install cargo-readme and rustdoc-stripper
        run: |
          cargo install cargo-readme
          cargo install rustdoc-stripper || true

      - name: Create wiki directories and template
        run: |
          # Create directory for wiki content
          mkdir -p wiki-content
          
          # Create Home.md
          echo "# ${GITHUB_REPOSITORY#*/} Documentation" > wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "This wiki contains automatically generated documentation from the Rust codebase." >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "## Modules" >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          
          # Create template file for cargo-readme
          echo "# {{title}}" > readme.tpl
          echo "" >> readme.tpl
          echo "Path: \`{{file_path}}\`" >> readme.tpl
          echo "" >> readme.tpl
          echo "{{readme}}" >> readme.tpl

      - name: Generate rust doc extractor
        run: |
          # Create a simple Rust script to extract docs
          cat > extract_doc_blocks.rs << 'EOF'
          use std::env;
          use std::fs;
          use std::io::{self, Write};
          use std::path::Path;
          
          fn main() -> io::Result<()> {
              let args: Vec<String> = env::args().collect();
              if args.len() < 2 {
                  eprintln!("Usage: {} <file_path>", args[0]);
                  std::process::exit(1);
              }
              
              let file_path = &args[1];
              let content = fs::read_to_string(file_path)?;
              
              let mut in_doc_comment = false;
              let mut doc_block = String::new();
              let mut pub_item = String::new();
              let mut doc_blocks = Vec::new();
              
              // Process file line by line
              for line in content.lines() {
                  let trimmed = line.trim();
                  
                  // Start of doc comment block
                  if trimmed.starts_with("///") {
                      // Extract just the comment content
                      let comment = trimmed.trim_start_matches("///").trim_start();
                      
                      // If this is the first doc comment in a block
                      if !in_doc_comment {
                          in_doc_comment = true;
                          doc_block = String::new();
                      }
                      
                      // Add comment to current block
                      doc_block.push_str(comment);
                      doc_block.push('\n');
                  } 
                  // Handle empty lines within doc comments
                  else if trimmed.is_empty() && in_doc_comment {
                      doc_block.push('\n');
                  }
                  // End of doc comment block, start of pub item
                  else if trimmed.starts_with("pub ") && in_doc_comment {
                      // Extract the item signature
                      pub_item = trimmed.to_string();
                      
                      // Add to doc blocks
                      doc_blocks.push((doc_block.clone(), pub_item.clone()));
                      
                      // Reset
                      in_doc_comment = false;
                      doc_block = String::new();
                      pub_item = String::new();
                  }
                  // Any other non-doc line resets the comment tracking
                  else {
                      in_doc_comment = false;
                  }
              }
              
              // Output the doc blocks with their pub items
              for (doc, item) in &doc_blocks {
                  // Skip empty docs
                  if doc.trim().is_empty() {
                      continue;
                  }
                  
                  // Extract item type and name for header
                  let header = extract_item_header(item);
                  println!("### {}", header);
                  println!("");
                  
                  // Print doc content
                  println!("{}", doc);
                  println!("");
                  
                  // Print code block with signature
                  println!("```rust");
                  println!("{}", item);
                  println!("```");
                  println!("");
              }
              
              Ok(())
          }
          
          fn extract_item_header(item: &str) -> String {
              // Extract struct/enum/fn name for header
              if let Some(cap) = item.strip_prefix("pub struct ") {
                  format!("struct {}", cap.split(|c| c == '{' || c == '<' || c == ' ').next().unwrap_or(""))
              } else if let Some(cap) = item.strip_prefix("pub enum ") {
                  format!("enum {}", cap.split(|c| c == '{' || c == '<' || c == ' ').next().unwrap_or(""))
              } else if let Some(cap) = item.strip_prefix("pub fn ") {
                  format!("fn {}", cap.split(|c| c == '(' || c == '<' || c == ' ').next().unwrap_or(""))
              } else if let Some(cap) = item.strip_prefix("pub async fn ") {
                  format!("async fn {}", cap.split(|c| c == '(' || c == '<' || c == ' ').next().unwrap_or(""))
              } else if let Some(cap) = item.strip_prefix("pub trait ") {
                  format!("trait {}", cap.split(|c| c == '{' || c == '<' || c == ' ').next().unwrap_or(""))
              } else if let Some(cap) = item.strip_prefix("pub type ") {
                  format!("type {}", cap.split(|c| c == '=' || c == '<' || c == ' ').next().unwrap_or(""))
              } else if let Some(cap) = item.strip_prefix("pub mod ") {
                  format!("mod {}", cap.split(|c| c == '{' || c == ' ').next().unwrap_or(""))
              } else if let Some(cap) = item.strip_prefix("pub const ") {
                  format!("const {}", cap.split(|c| c == ':' || c == ' ').next().unwrap_or(""))
              } else {
                  "item".to_string()
              }
          }
          EOF
          
          # Compile the doc extractor
          rustc extract_doc_blocks.rs

      - name: Process Rust files
        run: |
          # Find all .rs files
          find src -name "*.rs" -type f > rs_files.txt
          
          # Process each file
          while IFS= read -r file; do
            # Get file info
            base_name=$(basename "$file" .rs)
            dir_path=$(dirname "$file")
            
            # Create unique filename
            unique_name=$(echo "${dir_path//\//_}_${base_name}" | sed 's/^src_//')
            output_file="wiki-content/${unique_name}.md"
            
            echo "Processing $file into $output_file"
            
            # Create temporary directory for the "crate"
            temp_dir=$(mktemp -d)
            mkdir -p "$temp_dir/src"
            
            # Copy the file as lib.rs
            cp "$file" "$temp_dir/src/lib.rs"
            
            # Create minimal Cargo.toml
            echo "[package]" > "$temp_dir/Cargo.toml"
            echo "name = \"${base_name}\"" >> "$temp_dir/Cargo.toml"
            echo "version = \"0.1.0\"" >> "$temp_dir/Cargo.toml"
            echo "edition = \"2021\"" >> "$temp_dir/Cargo.toml"
            echo "" >> "$temp_dir/Cargo.toml"
            echo "[lib]" >> "$temp_dir/Cargo.toml"
            echo "path = \"src/lib.rs\"" >> "$temp_dir/Cargo.toml"
            
            # Create header for the wiki page
            echo "# $base_name ($dir_path)" > "$output_file"
            echo "" >> "$output_file"
            echo "Path: \`$file\`" >> "$output_file"
            echo "" >> "$output_file"
            
            # Create JSON file with variables
            echo "{\"title\":\"$base_name ($dir_path)\",\"file_path\":\"$file\"}" > "$temp_dir/readme_vars.json"
            
            # Extract module docs with cargo-readme
            (
              cd "$temp_dir"
              cargo readme --template "$GITHUB_WORKSPACE/readme.tpl" --no-title --no-badge --no-license --json readme_vars.json > module_docs.md || true
              
              # Check if we got module docs and append them
              if [ -s module_docs.md ]; then
                # Skip the header lines (first 3 lines) from cargo-readme output
                tail -n +4 module_docs.md >> "$GITHUB_WORKSPACE/$output_file"
              fi
            )
            
            # Extract public items and their doc comments
            echo "## Public API" >> "$output_file"
            echo "" >> "$output_file"
            
            # Run our custom doc extractor
            ./extract_doc_blocks "$file" >> "$output_file" || true
            
            # Add link to home page
            echo "* [$unique_name](${unique_name})" >> wiki-content/Home.md
            
            # Clean up
            rm -rf "$temp_dir"
          done < rs_files.txt

      - name: Setup Git for Wiki
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Clone Wiki Repository
        run: |
          # Use PAT for wiki push
          git clone https://${{ secrets.WIKI_TOKEN }}@github.com/${{ github.repository }}.wiki.git wiki-repo
          
          # Copy content to wiki
          cp -r wiki-content/* wiki-repo/
          
          cd wiki-repo
          git add .
          
          # Commit if changes exist
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update documentation from Rust code (${GITHUB_SHA:0:7})"
            git push
          fi

      - name: Upload Markdown as artifact
        uses: actions/upload-artifact@v4
        with:
          name: wiki-docs
          path: wiki-content/
