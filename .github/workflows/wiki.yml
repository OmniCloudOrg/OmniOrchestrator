name: Rust Docs to Wiki Generator

# This workflow extracts documentation from Rust source code files and generates
# a comprehensive wiki with proper documentation for all types of Rust items.
#
# Features:
# - Extracts module-level documentation (//! comments)
# - Processes doc comments for all public items (/// comments)
# - Handles struct, enum, trait, function, and other types
# - Generates a proper table of contents
# - Creates clean, well-formatted wiki pages
# - Organizes documentation hierarchically

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*.rs'
      - 'Cargo.toml'
      - '.github/workflows/rust-docs-to-wiki.yml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  generate-wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable

      - name: Create wiki directories
        run: |
          # Create directory for wiki content
          mkdir -p wiki-content
          
          # Create Home.md
          echo "# ${GITHUB_REPOSITORY#*/} Documentation" > wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "This wiki contains automatically generated documentation from the Rust codebase." >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "## Modules" >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md

      - name: Create rustdoc extractor
        run: |
          # This function-rich script processes Rust files and extracts documentation
          cat > rustdoc_extract.sh << 'EOF'
          #!/bin/bash
          
          # rustdoc_extract.sh - Extract documentation from Rust source files
          #
          # This script processes Rust source files and extracts documentation comments,
          # generating markdown files suitable for a GitHub wiki.
          
          # Exit on errors unless caught with ||
          set -eo pipefail
          
          # Print how to use this script
          function print_usage() {
            echo "Usage: $0 <source_dir> <output_dir>"
            echo ""
            echo "Arguments:"
            echo "  source_dir   Directory containing Rust source files"
            echo "  output_dir   Directory where wiki pages will be created"
          }
          
          # Extract module-level documentation (//! comments)
          function extract_module_docs() {
            local file="$1"
            local output_file="$2"
            
            echo "Extracting module documentation from $file"
            
            # Find all //! comments
            grep -n "^[[:space:]]*//!" "$file" | while read -r line_info; do
              # Extract line number and content
              line_num=$(echo "$line_info" | cut -d: -f1)
              line_content=$(echo "$line_info" | cut -d: -f2-)
              
              # Remove //! prefix and leading whitespace
              comment=$(echo "$line_content" | sed 's/^[[:space:]]*\/\/![[:space:]]*//')
              
              # Write to output
              echo "$comment" >> "$output_file.module_docs"
            done || true  # Don't fail if grep finds nothing
            
            # If we found module docs, add them to the wiki page
            if [ -f "$output_file.module_docs" ] && [ -s "$output_file.module_docs" ]; then
              echo "## Module Documentation" >> "$output_file"
              echo "" >> "$output_file"
              cat "$output_file.module_docs" >> "$output_file"
              echo "" >> "$output_file"
              rm "$output_file.module_docs"
            fi
          }
          
          # Create a table of contents based on public items
          function generate_table_of_contents() {
            local file="$1"
            local output_file="$2"
            
            echo "Generating table of contents for $file"
            
            echo "## Table of Contents" >> "$output_file"
            echo "" >> "$output_file"
            
            # Create a temporary file with all public items
            grep -n "^[[:space:]]*pub " "$file" > "$output_file.toc_items" || true
            
            # Process each item
            if [ -f "$output_file.toc_items" ] && [ -s "$output_file.toc_items" ]; then
              while read -r line_info; do
                # Extract line number and content
                line_num=$(echo "$line_info" | cut -d: -f1)
                line_content=$(echo "$line_info" | cut -d: -f2-)
                
                # Determine item type and name
                if [[ "$line_content" =~ pub[[:space:]]+struct[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="struct"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+enum[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="enum"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+trait[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="trait"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+fn[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="fn"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+async[[:space:]]+fn[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="async fn"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+type[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="type"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+mod[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="mod"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+const[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="const"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+use[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="use"
                  item_name="${BASH_REMATCH[1]}"
                else
                  # Handle any other pub item
                  item_type="item"
                  item_name=$(echo "$line_content" | sed 's/^[[:space:]]*pub[[:space:]]*\([^{; ]*\).*/\1/' || echo "unknown")
                fi
                
                # If we identified the item, add it to TOC
                if [ -n "$item_name" ] && [ "$item_name" != "unknown" ]; then
                  anchor=$(echo "$item_name" | tr '[:upper:]' '[:lower:]')
                  echo "* [$item_type $item_name](#$anchor)" >> "$output_file"
                fi
              done < "$output_file.toc_items"
              
              echo "" >> "$output_file"
            else
              echo "No public items found" >> "$output_file"
              echo "" >> "$output_file"
            fi
            
            rm -f "$output_file.toc_items"
          }
          
          # Process doc comments (///) and associate them with public items
          function extract_documented_items() {
            local file="$1"
            local output_file="$2"
            
            echo "Extracting documented items from $file"
            
            echo "## Public Items" >> "$output_file"
            echo "" >> "$output_file"
            
            # Create temporary file for all lines
            sed -n '1,$p' "$file" > "$output_file.all_lines"
            
            # Process the file line by line to match doc comments with items
            local line_count=$(wc -l < "$output_file.all_lines")
            local i=1
            local in_doc_comment=0
            local doc_comments=""
            
            while [ $i -le $line_count ]; do
              local line=$(sed -n "${i}p" "$output_file.all_lines")
              
              # Check for doc comments
              if [[ "$line" =~ ^[[:space:]]*\/\/\/ ]]; then
                # Get comment content without /// prefix
                local comment=$(echo "$line" | sed 's/^[[:space:]]*\/\/\/[[:space:]]*//')
                
                # Add to doc comments
                if [ $in_doc_comment -eq 0 ]; then
                  in_doc_comment=1
                  doc_comments="$comment"
                else
                  doc_comments="$doc_comments
$comment"
                fi
              # Handle empty line in doc comments
              elif [[ "$line" =~ ^[[:space:]]*$ ]] && [ $in_doc_comment -eq 1 ]; then
                doc_comments="$doc_comments

"
              # Check for public item after doc comments
              elif [[ "$line" =~ ^[[:space:]]*pub[[:space:]] ]] && [ $in_doc_comment -eq 1 ]; then
                # Extract item type and name
                local item_type=""
                local item_name=""
                
                if [[ "$line" =~ pub[[:space:]]+struct[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="struct"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ pub[[:space:]]+enum[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="enum"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ pub[[:space:]]+trait[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="trait"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ pub[[:space:]]+fn[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="fn"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ pub[[:space:]]+async[[:space:]]+fn[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="async fn"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ pub[[:space:]]+type[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="type"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ pub[[:space:]]+mod[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="mod"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ pub[[:space:]]+const[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="const"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ pub[[:space:]]+use[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="use"
                  item_name="${BASH_REMATCH[1]}"
                else
                  # Handle any other pub item
                  item_type="item"
                  item_name=$(echo "$line" | sed 's/^[[:space:]]*pub[[:space:]]*\([^{; ]*\).*/\1/' || echo "unknown")
                fi
                
                # Print header
                if [ -n "$item_name" ] && [ "$item_name" != "unknown" ]; then
                  echo "### $item_type $item_name" >> "$output_file"
                  echo "" >> "$output_file"
                  
                  # Print doc comments
                  echo "$doc_comments" >> "$output_file"
                  echo "" >> "$output_file"
                  
                  # Extract signature
                  extract_item_signature "$output_file.all_lines" $i "$item_type" >> "$output_file" || true
                  echo "" >> "$output_file"
                fi
                
                # Reset doc comment tracking
                in_doc_comment=0
                doc_comments=""
              else
                # Any other line resets doc comment tracking
                in_doc_comment=0
                doc_comments=""
              fi
              
              # Move to next line
              i=$((i + 1))
            done
            
            # Clean up temp file
            rm -f "$output_file.all_lines"
          }
          
          # Extract signature for a Rust item
          function extract_item_signature() {
            local file="$1"
            local start_line="$2"
            local item_type="$3"
            
            # Extract the first line
            local signature=$(sed -n "${start_line}p" "$file")
            
            # If it's a one-line item, return it
            if [[ "$signature" =~ \;$ ]]; then
              echo '```rust'
              echo "$signature"
              echo '```'
              return
            fi
            
            # For multi-line signatures, extract a reasonable amount
            echo '```rust'
            echo "$signature"
            
            # For structs and enums, capture fields/variants
            if [ "$item_type" == "struct" ] || [ "$item_type" == "enum" ]; then
              local max_lines=15  # Show at most this many lines
              local brace_count=0
              local line_num=$((start_line + 1))
              local count=1
              
              # Count opening braces in first line
              brace_count=$(echo "$signature" | tr -cd '{' | wc -c)
              brace_count=$((brace_count - $(echo "$signature" | tr -cd '}' | wc -c)))
              
              # Continue until we balance braces or hit max lines
              while [ $brace_count -gt 0 ] && [ $count -lt $max_lines ]; do
                if [ $line_num -gt $(wc -l < "$file") ]; then
                  break
                fi
                
                local next_line=$(sed -n "${line_num}p" "$file" || echo "")
                
                # Skip doc comments
                if [[ "$next_line" =~ ^[[:space:]]*\/\/\/ ]]; then
                  line_num=$((line_num + 1))
                  continue
                fi
                
                # Count braces
                local open_braces=$(echo "$next_line" | tr -cd '{' | wc -c)
                local close_braces=$(echo "$next_line" | tr -cd '}' | wc -c)
                brace_count=$((brace_count + open_braces - close_braces))
                
                # Add to signature
                echo "$next_line"
                
                line_num=$((line_num + 1))
                count=$((count + 1))
                
                # If we've balanced braces, we're done
                if [ $brace_count -eq 0 ]; then
                  break
                fi
              done
              
              # If we still have unclosed braces, add an ellipsis
              if [ $brace_count -gt 0 ]; then
                echo "    // ... additional fields/variants"
                echo "}"
              fi
            else
              # For functions, traits, etc., just show the first few lines
              local max_additional=5
              local line_num=$((start_line + 1))
              
              for ((j=0; j<max_additional; j++)); do
                if [ $line_num -gt $(wc -l < "$file") ]; then
                  break
                fi
                
                local next_line=$(sed -n "${line_num}p" "$file" || echo "")
                
                # Skip doc comments
                if [[ "$next_line" =~ ^[[:space:]]*\/\/\/ ]]; then
                  line_num=$((line_num + 1))
                  continue
                fi
                
                echo "$next_line"
                
                # If line has opening brace, add closing brace and stop
                if [[ "$next_line" =~ \{ ]]; then
                  echo "    // ... implementation"
                  echo "}"
                  break
                fi
                
                # If line has semicolon, we're done
                if [[ "$next_line" =~ \;$ ]]; then
                  break
                fi
                
                line_num=$((line_num + 1))
              done
            fi
            
            echo '```'
          }
          
          # Extract all public items, even if not documented
          function extract_all_public_items() {
            local file="$1"
            local output_file="$2"
            
            echo "Extracting all public items from $file"
            
            echo "## All Public Items" >> "$output_file"
            echo "" >> "$output_file"
            
            # Find all public items
            grep -n "^[[:space:]]*pub " "$file" > "$output_file.all_items" || true
            
            if [ -f "$output_file.all_items" ] && [ -s "$output_file.all_items" ]; then
              # Create a copy of the file for item extraction
              cp "$file" "$output_file.source"
              
              while read -r line_info; do
                # Extract line number and content
                line_num=$(echo "$line_info" | cut -d: -f1)
                line_content=$(echo "$line_info" | cut -d: -f2-)
                
                # Determine item type
                local item_type=""
                local item_name=""
                
                if [[ "$line_content" =~ pub[[:space:]]+struct[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="struct"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+enum[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="enum"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+trait[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="trait"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+fn[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="fn"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+async[[:space:]]+fn[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="async fn"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+type[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="type"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+mod[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="mod"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+const[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="const"
                  item_name="${BASH_REMATCH[1]}"
                elif [[ "$line_content" =~ pub[[:space:]]+use[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                  item_type="use"
                  item_name="${BASH_REMATCH[1]}"
                else
                  # Handle any other pub item
                  item_type="item"
                  item_name=$(echo "$line_content" | sed 's/^[[:space:]]*pub[[:space:]]*\([^{; ]*\).*/\1/' || echo "unknown")
                fi
                
                # If we identified the item, extract signature
                if [ -n "$item_name" ] && [ "$item_name" != "unknown" ]; then
                  echo "### $item_type $item_name" >> "$output_file"
                  echo "" >> "$output_file"
                  extract_item_signature "$output_file.source" "$line_num" "$item_type" >> "$output_file" || true
                  echo "" >> "$output_file"
                fi
              done < "$output_file.all_items"
              
              # Clean up
              rm -f "$output_file.source"
            else
              echo "No public items found." >> "$output_file"
              echo "" >> "$output_file"
            fi
            
            rm -f "$output_file.all_items"
          }
          
          # Safely process a Rust file with error handling
          function safe_process_rust_file() {
            local file="$1"
            local output_dir="$2"
            
            # Create unique filename for wiki page
            local base_name=$(basename "$file" .rs)
            local dir_path=$(dirname "$file")
            local unique_name=$(echo "${dir_path//\//_}_${base_name}" | sed 's/^src_//')
            local output_file="$output_dir/${unique_name}.md"
            
            echo "Processing $file"
            
            # Create page header
            echo "# $base_name ($dir_path)" > "$output_file"
            echo "" >> "$output_file"
            echo "Path: \`$file\`" >> "$output_file"
            echo "" >> "$output_file"
            
            # Extract documentation sections with error handling
            extract_module_docs "$file" "$output_file" || echo "Warning: Error extracting module docs from $file"
            generate_table_of_contents "$file" "$output_file" || echo "Warning: Error generating TOC for $file"
            extract_documented_items "$file" "$output_file" || echo "Warning: Error extracting documented items from $file"
            extract_all_public_items "$file" "$output_file" || echo "Warning: Error extracting all public items from $file"
            
            # Add link to Home.md
            echo "* [$unique_name](${unique_name})" >> "$output_dir/Home.md"
            
            echo "Completed processing $file -> $output_file"
          }
          
          # Main processing function
          function process_all_rust_files() {
            local source_dir="$1"
            local output_dir="$2"
            
            # Find all Rust files
            find "$source_dir" -name "*.rs" -type f | while read -r file; do
              safe_process_rust_file "$file" "$output_dir" || echo "Error processing $file, continuing with next file"
            done
          }
          
          # Script entry point
          if [ "$#" -lt 2 ]; then
            print_usage
            exit 1
          fi
          
          source_dir="$1"
          output_dir="$2"
          
          # Validate directories
          if [ ! -d "$source_dir" ]; then
            echo "Error: Source directory does not exist: $source_dir"
            exit 1
          fi
          
          if [ ! -d "$output_dir" ]; then
            echo "Error: Output directory does not exist: $output_dir"
            exit 1
          fi
          
          # Process all Rust files
          echo "Starting documentation extraction from $source_dir to $output_dir"
          process_all_rust_files "$source_dir" "$output_dir"
          echo "Documentation extraction complete!"
          
          # Return success
          exit 0
          EOF
          
          # Make script executable
          chmod +x rustdoc_extract.sh

      - name: Generate Wiki Documentation
        run: |
          # Run the doc extraction script
          ./rustdoc_extract.sh src wiki-content

      - name: Setup Git for Wiki
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Clone Wiki Repository
        run: |
          # Use PAT for wiki push
          git clone https://${{ secrets.WIKI_TOKEN }}@github.com/${{ github.repository }}.wiki.git wiki-repo
          
          # Copy content to wiki
          cp -r wiki-content/* wiki-repo/
          
          cd wiki-repo
          git add .
          
          # Commit if changes exist
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update documentation from Rust code (${GITHUB_SHA:0:7})"
            git push
          fi

      - name: Upload Markdown as artifact
        uses: actions/upload-artifact@v4
        with:
          name: wiki-docs
          path: wiki-content/
