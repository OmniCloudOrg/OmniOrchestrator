name: Rust Docs to Wiki

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*.rs'
      - 'Cargo.toml'
      - '.github/workflows/rust-docs-to-wiki.yml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  extract-docs-and-update-wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable

      - name: Generate documentation
        run: |
          # Create directory for wiki content
          mkdir -p wiki-content
          
          # Create Home.md
          echo "# ${GITHUB_REPOSITORY#*/} Documentation" > wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "This wiki contains automatically generated documentation from the Rust codebase." >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "## Modules" >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          
          # Process each source file
          find src -name "*.rs" -type f | while read -r file; do
            # Get file info
            base_name=$(basename "$file" .rs)
            dir_path=$(dirname "$file")
            
            # Convert path to a unique filename by replacing slashes with underscores
            unique_name=$(echo "${dir_path//\//_}_${base_name}" | sed 's/^src_//')
            output_file="wiki-content/${unique_name}.md"
            
            echo "Processing $file into $output_file"
            
            # Create the wiki page header
            echo "# $base_name ($dir_path)" > "$output_file"
            echo "" >> "$output_file"
            echo "Path: \`$file\`" >> "$output_file"
            echo "" >> "$output_file"
            
            # Extract module-level docs (//!)
            grep -n "^//!" "$file" | sed 's/^[0-9]*://g' | sed 's/\/\/!\s*//' > module_docs.txt
            if [ -s module_docs.txt ]; then
              echo "## Module Documentation" >> "$output_file"
              echo "" >> "$output_file"
              cat module_docs.txt >> "$output_file"
              echo "" >> "$output_file"
            fi
            rm module_docs.txt
            
            # Generate table of contents from public items
            echo "## Table of Contents" >> "$output_file"
            echo "" >> "$output_file"
            
            # Find public items with doc comments for the TOC
            grep -n "^pub " "$file" | while read -r line_info; do
              line_num=$(echo "$line_info" | cut -d: -f1)
              item=$(echo "$line_info" | cut -d: -f2-)
              
              # Extract item type and name
              item_type=""
              item_name=""
              
              if [[ "$item" =~ pub[[:space:]]+struct[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                item_type="struct"
                item_name="${BASH_REMATCH[1]}"
              elif [[ "$item" =~ pub[[:space:]]+enum[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                item_type="enum"
                item_name="${BASH_REMATCH[1]}"
              elif [[ "$item" =~ pub[[:space:]]+fn[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                item_type="fn"
                item_name="${BASH_REMATCH[1]}"
              elif [[ "$item" =~ pub[[:space:]]+trait[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                item_type="trait"
                item_name="${BASH_REMATCH[1]}"
              elif [[ "$item" =~ pub[[:space:]]+mod[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                item_type="mod"
                item_name="${BASH_REMATCH[1]}"
              elif [[ "$item" =~ pub[[:space:]]+type[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                item_type="type"
                item_name="${BASH_REMATCH[1]}"
              elif [[ "$item" =~ pub[[:space:]]+const[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                item_type="const"
                item_name="${BASH_REMATCH[1]}"
              fi
              
              if [ -n "$item_name" ]; then
                # Check if this item has doc comments above it
                prev_line=$((line_num - 1))
                if grep -q "^///" <(sed -n "${prev_line}p" "$file"); then
                  anchor=$(echo "$item_name" | tr '[:upper:]' '[:lower:]')
                  echo "* [$item_type $item_name](#$anchor)" >> "$output_file"
                fi
              fi
            done
            
            echo "" >> "$output_file"
            echo "## Public Items" >> "$output_file"
            echo "" >> "$output_file"
            
            # Process public items with their documentation
            grep -n "^pub " "$file" | while read -r line_info; do
              line_num=$(echo "$line_info" | cut -d: -f1)
              item=$(echo "$line_info" | cut -d: -f2-)
              
              # Extract item type and name
              item_type=""
              item_name=""
              
              if [[ "$item" =~ pub[[:space:]]+struct[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                item_type="struct"
                item_name="${BASH_REMATCH[1]}"
              elif [[ "$item" =~ pub[[:space:]]+enum[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                item_type="enum"
                item_name="${BASH_REMATCH[1]}"
              elif [[ "$item" =~ pub[[:space:]]+fn[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                item_type="fn"
                item_name="${BASH_REMATCH[1]}"
              elif [[ "$item" =~ pub[[:space:]]+trait[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                item_type="trait"
                item_name="${BASH_REMATCH[1]}"
              elif [[ "$item" =~ pub[[:space:]]+mod[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                item_type="mod"
                item_name="${BASH_REMATCH[1]}"
              elif [[ "$item" =~ pub[[:space:]]+type[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                item_type="type"
                item_name="${BASH_REMATCH[1]}"
              elif [[ "$item" =~ pub[[:space:]]+const[[:space:]]+([a-zA-Z0-9_]+) ]]; then
                item_type="const"
                item_name="${BASH_REMATCH[1]}"
              fi
              
              if [ -n "$item_name" ]; then
                # Get doc comments above this item
                doc_comments=""
                i=$((line_num - 1))
                while [ $i -ge 1 ]; do
                  line=$(sed -n "${i}p" "$file")
                  if [[ "$line" =~ ^[[:space:]]*/// ]]; then
                    # Extract comment content without ///
                    comment=$(echo "$line" | sed 's/^[[:space:]]*\/\/\/[[:space:]]*//')
                    doc_comments="$comment\n$doc_comments"
                    i=$((i - 1))
                  elif [[ "$line" =~ ^[[:space:]]*$ ]]; then
                    # Skip empty lines
                    i=$((i - 1))
                  else
                    # Stop at any non-comment, non-empty line
                    break
                  fi
                done
                
                # Extract the item signature (single line or first line for multi-line items)
                signature=$(echo "$item" | sed -E 's/\{.*$//')
                
                # Write item header and documentation
                echo "### $item_type $item_name" >> "$output_file"
                echo "" >> "$output_file"
                
                if [ -n "$doc_comments" ]; then
                  echo -e "$doc_comments" >> "$output_file"
                  echo "" >> "$output_file"
                fi
                
                # Write code block with signature
                echo '```rust' >> "$output_file"
                echo "pub $signature" >> "$output_file"
                echo '```' >> "$output_file"
                echo "" >> "$output_file"
              fi
            done
            
            # Add a link to the home page
            echo "* [$unique_name](${unique_name})" >> wiki-content/Home.md
          done

      - name: Setup Git for Wiki
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Clone Wiki Repository
        run: |
          # Use PAT for wiki push (needs to be set in repository secrets)
          git clone https://${{ secrets.WIKI_TOKEN }}@github.com/${{ github.repository }}.wiki.git wiki-repo
          
          # Copy new content to wiki repository
          cp -r wiki-content/* wiki-repo/
          
          cd wiki-repo
          git add .
          
          # Only commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update documentation from Rust code (${GITHUB_SHA:0:7})"
            git push
          fi

      - name: Upload Markdown as artifact
        uses: actions/upload-artifact@v4
        with:
          name: wiki-docs
          path: wiki-content/
