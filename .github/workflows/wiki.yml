name: Rust Docs to Wiki Generator

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*.rs'
      - 'Cargo.toml'
      - '.github/workflows/rust-docs-to-wiki.yml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  generate-wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable

      - name: Create wiki directories
        run: |
          # Create directory for wiki content
          mkdir -p wiki-content
          
          # Create Home.md
          echo "# ${GITHUB_REPOSITORY#*/} Documentation" > wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "This wiki contains automatically generated documentation from the Rust codebase." >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md
          echo "## Modules" >> wiki-content/Home.md
          echo "" >> wiki-content/Home.md

      - name: Create rustdoc extractor
        run: |
          # This script processes Rust files and extracts documentation
          cat > extract_docs.py << 'EOF'
          #!/usr/bin/env python3
          import os
          import re
          import sys
          import subprocess
          from pathlib import Path
          
          def main():
              if len(sys.argv) < 3:
                  print("Usage: python extract_docs.py <source_dir> <output_dir>")
                  return 1
                  
              source_dir = Path(sys.argv[1])
              output_dir = Path(sys.argv[2])
              
              if not source_dir.is_dir():
                  print(f"Error: Source directory does not exist: {source_dir}")
                  return 1
                  
              if not output_dir.is_dir():
                  print(f"Error: Output directory does not exist: {output_dir}")
                  return 1
              
              # Process all Rust files
              rust_files = list(source_dir.glob("**/*.rs"))
              for file_path in sorted(rust_files):
                  process_file(file_path, source_dir, output_dir)
              
              return 0
          
          def process_file(file_path, source_dir, output_dir):
              """Process a single Rust file and extract documentation"""
              # Create unique filename for wiki page
              rel_path = file_path.relative_to(source_dir)
              unique_name = str(rel_path).replace('/', '_').replace('.rs', '')
              output_file = output_dir / f"{unique_name}.md"
              
              print(f"Processing {file_path} -> {output_file}")
              
              # Get file info
              base_name = file_path.stem
              dir_path = str(file_path.parent)
              
              with open(output_file, "w") as f:
                  # Create header
                  f.write(f"# {base_name} ({dir_path})\n\n")
                  f.write(f"Path: `{file_path}`\n\n")
                  
                  # Extract module docs
                  module_docs = extract_module_docs(file_path)
                  if module_docs:
                      f.write("## Module Documentation\n\n")
                      f.write(module_docs)
                      f.write("\n\n")
                  
                  # Extract public items
                  items = extract_public_items(file_path)
                  if items:
                      f.write("## Table of Contents\n\n")
                      for item_type, item_name, _, _ in items:
                          f.write(f"* [{item_type} {item_name}](#{item_name.lower()})\n")
                      f.write("\n")
                      
                      f.write("## Public Items\n\n")
                      for item_type, item_name, doc_comment, signature in items:
                          f.write(f"### {item_type} {item_name}\n\n")
                          if doc_comment:
                              f.write(format_doc_comment(doc_comment))
                              f.write("\n\n")
                          f.write("```rust\n")
                          f.write(signature)
                          f.write("\n```\n\n")
              
              # Add link to Home.md
              with open(output_dir / "Home.md", "a") as f:
                  f.write(f"* [{unique_name}]({unique_name})\n")
          
          def extract_module_docs(file_path):
              """Extract module-level documentation (//! comments)"""
              module_docs = []
              with open(file_path, "r") as f:
                  for line in f:
                      if re.match(r'^\s*//!', line):
                          comment = re.sub(r'^\s*//!\s?', '', line).rstrip()
                          module_docs.append(comment)
              
              return format_doc_comment("\n".join(module_docs)) if module_docs else ""
          
          def extract_public_items(file_path):
              """Extract public items with their doc comments"""
              items = []
              
              with open(file_path, "r") as f:
                  content = f.read()
              
              # Split into lines
              lines = content.split('\n')
              i = 0
              
              while i < len(lines):
                  # Skip empty lines
                  if not lines[i].strip():
                      i += 1
                      continue
                  
                  # Look for doc comments
                  if re.match(r'^\s*///', lines[i]):
                      doc_lines = []
                      start_line = i
                      
                      # Collect all doc lines
                      while i < len(lines) and re.match(r'^\s*///', lines[i]):
                          comment = re.sub(r'^\s*///\s?', '', lines[i]).rstrip()
                          doc_lines.append(comment)
                          i += 1
                      
                      # Skip whitespace
                      while i < len(lines) and not lines[i].strip():
                          i += 1
                      
                      # Check if followed by a public item
                      if i < len(lines) and re.match(r'^\s*pub\s', lines[i]):
                          pub_line = lines[i]
                          
                          # Extract item type and name
                          item_type = "item"
                          item_name = ""
                          
                          if "pub struct " in pub_line:
                              item_type = "struct"
                              match = re.search(r'struct\s+([a-zA-Z0-9_]+)', pub_line)
                              if match:
                                  item_name = match.group(1)
                          elif "pub enum " in pub_line:
                              item_type = "enum"
                              match = re.search(r'enum\s+([a-zA-Z0-9_]+)', pub_line)
                              if match:
                                  item_name = match.group(1)
                          elif "pub trait " in pub_line:
                              item_type = "trait"
                              match = re.search(r'trait\s+([a-zA-Z0-9_]+)', pub_line)
                              if match:
                                  item_name = match.group(1)
                          elif "pub async fn " in pub_line:
                              item_type = "async fn"
                              match = re.search(r'async\s+fn\s+([a-zA-Z0-9_]+)', pub_line)
                              if match:
                                  item_name = match.group(1)
                          elif "pub fn " in pub_line:
                              item_type = "fn"
                              match = re.search(r'fn\s+([a-zA-Z0-9_]+)', pub_line)
                              if match:
                                  item_name = match.group(1)
                          
                          # Extract signature
                          signature_lines = [pub_line]
                          sig_end = i + 1
                          
                          # For multi-line signatures
                          if "{" in pub_line and "}" not in pub_line:
                              braces = 1
                              while sig_end < len(lines) and braces > 0:
                                  line = lines[sig_end]
                                  braces += line.count("{") - line.count("}")
                                  signature_lines.append(line)
                                  sig_end += 1
                                  # Limit the amount we collect
                                  if sig_end > i + 15:
                                      signature_lines.append("    // ... implementation")
                                      signature_lines.append("}")
                                      break
                          elif "{" not in pub_line and ";" not in pub_line:
                              # Multi-line signature without body yet
                              while sig_end < len(lines) and ";" not in lines[sig_end] and "{" not in lines[sig_end]:
                                  signature_lines.append(lines[sig_end])
                                  sig_end += 1
                                  
                                  # If we hit opening brace
                                  if sig_end < len(lines) and "{" in lines[sig_end]:
                                      signature_lines.append(lines[sig_end])
                                      signature_lines.append("    // ... implementation")
                                      signature_lines.append("}")
                                      sig_end += 1
                                      break
                                  
                                  # Limit the amount we collect
                                  if sig_end > i + 10:
                                      break
                          
                          signature = "\n".join(signature_lines)
                          
                          # Add the item to our list
                          if item_name:
                              items.append((item_type, item_name, "\n".join(doc_lines), signature))
                          
                          i = sig_end
                          continue
                  
                  i += 1
              
              return items
          
          def format_doc_comment(text):
              """Format documentation with proper markdown"""
              # Fix headers - ensure # headings start on their own line
              text = re.sub(r'([^\n])# ([A-Z][a-zA-Z]+)', r'\1\n\n## \2', text)
              
              # Ensure proper spacing around lists
              text = re.sub(r'([^\n])\* ', r'\1\n\n* ', text)
              
              # Fix spacing in paragraphs
              text = re.sub(r'\.([A-Z])', r'. \1', text)
              
              # Ensure backticks for code references
              text = re.sub(r'`([^`]+)`', r'`\1`', text)
              
              return text
          
          if __name__ == "__main__":
              sys.exit(main())
          EOF
          
          # Make script executable
          chmod +x extract_docs.py

      - name: Generate Wiki Documentation
        run: |
          # Run the doc extraction script
          python3 extract_docs.py src wiki-content

      - name: Setup Git for Wiki
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Clone Wiki Repository
        run: |
          # Use PAT for wiki push
          git clone https://${{ secrets.WIKI_TOKEN }}@github.com/${{ github.repository }}.wiki.git wiki-repo
          
          # Copy content to wiki
          cp -r wiki-content/* wiki-repo/
          
          cd wiki-repo
          git add .
          
          # Commit if changes exist
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update documentation from Rust code (${GITHUB_SHA:0:7})"
            git push
          fi

      - name: Upload Markdown as artifact
        uses: actions/upload-artifact@v4
        with:
          name: wiki-docs
          path: wiki-content/
